---
title: 操作系统
abbrlink: cf3a69eb
date: 2022-09-23 10:31:06
tags:
  - Computer
  - Operation System
category: Computer Theory
---
## 1 操作系统概述

### 1.1 基本概念与功能

- <u>概念</u>：操作系统（Operating System，OS）是指

  - 控制和管理整个计算机系统的**硬件和软件资源**，并合理地**组织调度计算机的工作**和资源的分配，
  - 以提供给用户和其他软件方便的**接口调用和环境**的系统软件，
  - 它是计算机系统中**最基本的系统软件**。

  > 简单来说，
  >
  > - 从程序的角度来讲，操作系统就是**对象+API（系统调用）**；
  > - 从硬件的角度来讲，操作系统就是一个**C程序代码**
  >
- <u>功能与目标</u>

  - **系统资源**的管理者：安全高效

    - 进程管理
    - 内存管理
    - 文件管理
    - 设备管理
  - 用户和计算机硬件之间的**接口**：方便使用

    - **命令接口**：允许用户**直接使用**

      - **联机**命令接口/**交互式**命令接口

        > 比如dos窗口
        >
      - **脱机**命令接口/**批处理**命令接口

        > 比如.bat文件
        >
    - **程序接口**：由一组**系统调用**组成，允许用户通过程序**间接使用**

      > 比如.dll文件；
      >
      > 系统调用命令也称为**广义指令**
      >
    - GUI：图形用户接口
  - 最**接近硬件**的层次

### 1.2 基本特征

- 两个最基本特征：并发和共享

  - **<u>并发</u>**：操作系统会**协调多个程序交替执行**

    > 操作系统就是伴随着“多道程序技术”而出现的
    >
  - **<u>共享</u>**：系统**资源**可供多个**并发进程<u>互斥</u>地或<u>同时</u>地使用**

    - 互斥共享方式
    - 同时共享方式
  - 并发和共享是操作系统**最基本的两个特征**，互为存在条件
- 虚拟：操作系统将<u>内存、处理器</u>等**物理实体扩展映射为若干个逻辑对应物**
- 异步性：由于**资源有限**，**多进程**并发地**以不可预知的速度推进**

### 1.3 发展与分类

1. <u>手工操作阶段</u>时，**人机速度矛盾**突出，**资源利用率**低
2. <u>批处理阶段</u>

   1. <u>单道批处理阶段</u>中，引入了**脱机输入/输出**技术，并有**监督程序**负责控制作业的输入、输出

      > 监督程序也是操作系统的原型
      >
   2. <u>多道批处理阶段</u>中，操作系统诞生，其中引入了**中断**技术，多个**程序并发执行**，资源利用率提高，但不能**人机交互**

      > **中断**是**操作系统**必须提供的功能；**时钟中断**为多道程序设计模型的理论基础
      >

   > 批处理系统的主要缺点就是**交互性**差
   >
3. <u>分时操作系统</u>以**时间片**为单位轮流运行多个程序，解决了**人机交互**问题，允许**多个用户同时使用**一台计算机，但不能优先响应**紧急**任务

   > 通用操作系统使用时间片轮转调度算法
   >
4. <u>实时操作系统</u>能**优先响应紧急任务**，具有及时性和可靠性

   - 硬实时系统：必须在绝对严格的规定时间内完成处理
   - 软实时系统：能接受偶尔违反时间规定

### 1.4 运行机制和体系结构

- <u>运行机制/两种处理器状态</u>：

  - 核心态（管态）

    - 可执行**特权指令、非特权指令**

      > 特权指令只允许**操作系统/内核**使用，
      >
      > 如内存清零指令、置时钟指令、关中断指令
      >
    - 运行**内核程序**

      > 如普通的运算指令
      >
  - 用户态（目态）

    - 只能**非特权指令**
    - 运行**用户程序**
  - 用户态与核心态切换：修改**程序状态字PSW**

    - 用户态下需要运行**中断指令/访管指令/trap指令**才能修改PSW

      > **中断**是用户态进入内核态的唯一途径，**中断指令**是唯一运行在用户态但不会运行在内核态下的指令。
      >
    - 核心态下可以**直接修改PSW**，运行**中断返回用户程序**即可转换回用户态
  - 区分执行态的目的：保护系统程序
- <u>体系结构</u>：操作系统**内核/内核程序**可包含的功能

  - **时钟**管理
  - **中断**处理
  - **原语**（设备驱动、CPU切换）
  - **资源**管理：进程管理、内存管理、设备管理

    > 根据是否包含**资源管理**相关功能，可分类为**宏内核、微内核**
    >
    > - 宏内核：高性能，但结构复杂难以维护、可能不稳定
    > - 微内核：结构清晰方便维护、稳定，但性能低
    >

### 1.5 中断和异常

- <u>中断的概念/本质</u>

  - 发生中断就意味着**需要操作系统介入**，进入**核心态**，开展管理工作。

    - 中断是使<u>CPU从用户态进入核心态的唯一方式</u>。
    - 本质是修改PSW，核心态下可以直接修改，用户态下只能通过中断修改。
  - 中断由运行在核心态下的**中断处理程序**处理
- <u>中断的分类</u>

  - 内中断/软件中断/**异常**

    - 系统调用等**陷入**（trap）
    - 硬件**故障**（fault）

      > 例如：缺页
      >
    - 程序**终止**（abort）

      > 例如：除0
      >
  - 外中断/硬件中断：**狭义的中断**

    - 外设请求

      > 例如：I/O操作完成
      >
    - 人工干预

      > 例如：用户强行终止一个进程
      >

  > “内外”是相对CPU而言
  >
- <u>中断的处理</u>：

  - 检测
    - 内中断/异常由CPU检测，不能被屏蔽，一旦出现立即处理
  - 中断由硬件保护并更新 PC ，主要是保证系统运行可靠、正确
  - 运行环境
    - 从用户态到核心态的转换是由**硬件中断机制**完成的
    - **进入中断处理**的程序、**中断处理**程序、**中断返回**程序均运行在内核态
- 中断隐指令保存的寄存器

  - 断点（PC）
  - 程序状态寄存器PSW
  - 操作系统保存的寄存器
  - 通用寄存器

### 1.6 系统调用

- <u>系统调用的概念</u>

  - 系统调用是**操作系统提供给应用程序调用的特殊函数/接口**
  - 系统调用命令也叫**广义指令**，在**用户态下调用**，在**内核态下执行**

    > 注意区分：
    >
    > - 系统调用命令/广义指令
    > - 中断指令/访管指令/trap指令
    >
- <u>系统调用的功能</u>：用来获得**操作系统的服务**，在一情况下保证系统的**稳定性和安全性**

  - 进程管理
    - 进程控制
    - 进程通信
  - 内存管理
  - 设备管理、文件管理
- <u>系统调用与中断</u>：

  - 系统调用命令编译后会形成参数和**陷入指令**，引发陷入类型的**内中断**，从而使CPU从用户态进入**核心态**，执行系统调用相应服务程序。
  - **陷入指令是在用户态执行的**，该指令会引发**内中断**，然后由**硬件**跳转至**陷阱处理器**（trap handler），切换至**内核模式**，处理陷阱（handle trap），执行系统调用
- <u>库函数</u>

  - 库函数是语言或应用程序的一部分，可以运行在**用户空间**中
  - 库函数可以**封装系统调用**

    > 未封装系统调用的库函数执行效率通常更高；
    >
    > 应用程序可以直接使用系统调用，也可以使用封装了系统调用的库函数
    >

## 2 进程管理

### 2.1 进程与线程概述

#### *进程概念与组成：*

- <u>进程的**概念**</u>

  - 进程是**程序的一次执行过程**，是系统进行**资源分配**（和调度）的**基本单位**

    > 程序：指令序列
    >
- <u>**进程实体/进程映像**的**组成**</u>

  - 程序段
  - 数据段
  - **PCB**
    - 进程**描述/标志**信息：进程标识符（**PID**）、用户标识符（**UID**）
    - 进程**控制和管理**信息：进程当前**状态**、进程当前**优先级**
    - **资源分配**清单：程序段和数据段的**指针**、键盘鼠标
    - **处理机**相关信息：各种**寄存器**值、CPU状态

  > C语言程序的组成：
  >
  > - PCB
  > - 正文段：代码段和赋值数据段
  >
  >   > 包括全局赋值变量、常量等
  >   >
  > - 数据堆段：动态分配
  > - 数据栈段：临时变量
  >
  >   > 包括未赋值局部变量、实参传递等
  >   >
  >
- <u>进程的**组织方式**</u>

  - **链接**方式：按照进程**状态**将PCB组织为多个**队列**
  - **索引**方式：按照进程**状态**将进程组织为多张**索引表**
- <u>进程的特征</u>

  - 动态性（最基本）：程序的运行过程
  - 独立性：资源分配（和接受调度）的基本单位

    > 进程有自己独立的地址空间，有PCB；
    >
    > 并发进程可能因共享变量而失去独立性
    >
  - 并发性
  - 异步性
  - 结构性
  - 封闭性：进程的执行速度不影响执行结果

    > 在**并发进程共享**时，可能失去封闭性
    >

---

#### *进程的状态：*

- <u>状态划分</u>：为了**方便对各个进程的管理**，操作系统将进程合理地划分为几种**状态**

  - 三种基本状态

    - 运行态：占有CPU并**在CPU上运行**

      > 单处理系统并非任何时刻都有进程在运行，因为可能出现**死锁**
      >
    - 就绪态：**具备运行条件**但不占有CPU，从而不能运行
    - 阻塞态：因等待某一事件而暂时不能运行

      > 可能所有进程都处于**阻塞态**（例如死锁），但不可能所有进程都处于**就绪态**
      >
  - 两种始末状态

    - 创建态：正在被**创建**并**分配资源**
    - 终止态：正在从系统中**撤销**并**回归资源**
  - 两种内存调度的挂起状态

    - 就绪挂起
    - 阻塞挂起
- <u>进程控制</u>：进程的状态转换称为**进程控制**，进程控制用**原语**实现

  > 原语的本质是**关中断**、执行某些操作、**开中断**
  >

  - 创建：分配**资源**，申请并初始化**PCB**（设置为**就绪态**）并将其加入**就绪队列**
  - 撤销：找到对应**PCB**，剥夺**CPU**，**终止进程**（和子进程），归还**资源**，**删除PCB**
  - 阻塞：找到对应**PCB**，**保持运行现场**，**暂停**进程运行，将PCB设置为“**阻塞态**”并插入相应**阻塞队列**
  - 唤醒：在**阻塞队列**中找到对应**PCB**，将PCB从中移除并设置为“**就绪态**”、加入**就绪队列**
  - 切换：将当前进程**运行环境**信息存入PCB，移入相应队列，选择另一个进程，更新其PCB并恢复其运行环境

---

#### *进程通信：*

- 进程通信的概念
  - 进程通信就是指**进程之间的信息交换**
  - 进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的**内存地址空间相互独立**，但进程之间也需要**通信**。
- 进程通信的方法：
  - 共享存储：在内存中划分出一块**共享存储区**，由两个进程**互斥访问**
  - 消息传递：进程间以“**消息(Message)**”这种数据结构为单位，通过操作系统提供的**“发送消息、接收消息”两个原语**进行数据交换
    - 直接通信：消息直接挂到接收进程的**消息缓冲队列**上
    - 间接通信：消息要先发送到**中间实体（信箱）**中，因此也称”信箱通信方式“
- 管道通信：开辟**内存缓冲**区进行**半双工通信**

---

#### *线程：*

- <u>线程的概念与特点</u>

  - 线程是一个**基本的CPU执行单元**，是**CPU调度的基本单位**

    > 进程不再是**CPU调度的基本单位**了，但依然是**操作系统资源分配的基本单位**
    >

    > Linux系统的线程就是LWP(light weight process)，与Windows对线程的实现有较大差别
    >
  - 线程**提升了系统的并发度**，并发所带来的**系统开销减少**，**数据通信和共享**方便

    > 因为线程是得到CPU时间片的基本单位，一个进程有更多的线程，得到CPU时间片的概率就会变大
    >
- <u>线程的属性</u>

  - 地位：**CPU调度的基本单位**，有自己的ID和**线程控制块**（TCB）

    > 注意，线程和进程都有**控制块**，但线程**没有独立地址空间**；
    >
    > 线程包含CPU现场，可以独立执行程序
    >
  - 状态：三种基本状态和两种始末状态
  - 共享：同一进程的多个线程**共享进程资源（包括地址空间）**

    > TCB中指向内存资源的**三级页表是相同的**
    >
  - 切换：不同进程的线程切换可以引起进程切换，开销较大；同一进程的线程切换开销较小
- <u>线程的实现方式</u>

  - 用户级线程：由应用程序通过**线程库**实现，由**应用程序负责管理**，在**用户态**下即可切换，**对操作系统透明**
  - 内核级线程：由**操作系统直接管理**，线程调度、切换需要在**核心态**下完成；只有内核级线程才是**处理机分配的基本单位**。

    > 对于Linux操作系统，线程对于**内核**来说其实就是**进程**，只不过是轻量级的，所谓TCB其实也是一种PCB。内核通过**LWP线程号**区分线程。
    >
- <u>多线程模型</u>

  - 多对一：多个用户级线程映射到一个内核级线程。开销小，效率高，并发度低

    > 这种情况下一个线程被阻塞，则其所在进程也阻塞
    >
  - 一对一：一个用户级线程映射到一个内核级线程。并发能力强，成本高，开销大
  - 多对多模型：n用户及线程映射到m个内核级线程(n>=m)。平衡了**并发度**与**系统开销**

### 2.2 进程调度

#### *处理机调度概述：*

- <u>处理机调度的概念</u>：

  - 从进程**队列**中按照一定的算法选择一个进程并将**处理机分配**给它运行
- <u>处理机调度的层次</u>：

  - **作业**调度/高级调度（后备队列）：

    > 只调入和调出一次
    >

    - 调入：从外存后备队列中挑选作业分配资源，并建立相应进程（PCB）
    - 调出：作业运行结束后调出，撤销PCB
  - **内存**调度/中级调度（挂起队列）：

    - 调出：将暂时不能运行的进程调至**外存**，进入挂起状态；PCB仍在内存，记录进程数据位置，加入**挂起队列**
    - 调入：将处于挂起状态并具备运行条件的进程重新调入内存
  - **进程**调度/低级调度（就绪队列）：从**就绪队列**中选取**进程**将处理机分配给它，是最基本的调度，频率很高
- <u>处理机调度的方式</u>：

  - 进程（调度）切换主要包括对**原进程数据的保存**和**新进程数据的恢复**
  - 需要考虑调度问题的时机：
    - 当前运行的进程**主动放弃**处理机（非抢占式和抢占式）
    - **新的进程进入**就绪队列（抢占式）
  - 不能调度与切换的时机：
    - 处理**中断**
    - **内核程序临界区**
    - **原子操作**

---

#### *调度算法评价指标：*

- <u>CPU利用率</u>：CPU“**忙碌**”的时间占**总时间**的比例
- <u>系统吞吐量</u>：单位时间内完成作业的数量
- <u>周转时间</u>：
  - 从**作业被提交给系统**开始，到**作业完成**为止的时间间隔
  - 带权周转时间：**周转时间**除以作业实际**运行时间**
- <u>等待时间</u>：进程/作业处于**等待处理机**状态时间之和
- <u>响应时间</u>：从用户提交请求到**首次产生响应**所用的时间

---

#### *注重周转时间调度算法：*

- <u>先来先服务（FCFS）</u>：按照作业/进程**到达的先后顺序**进行服务（非抢占）

  > **等待时间**最长的优先得到服务
  >

  - 优点：公平、算法实现简单
  - 缺点：对长作业/进程后面的短作业/进程不利

    > FCFS算法**对长作业有利**，对短作业不利
    >
    >> 注意，这里的长指的是**CPU计算的时间长**，即**CPU密集型**，而不是指I/O时间很长（即**I/O密集型**），毕竟I/O阻塞的时候是会放弃CPU的
    >>
    >
- <u>短作业/进程优先（SJF/SPF）</u>：**最短**的作业/进程优先得到服务（抢占、非抢占）

  > **运行时间**最短的优先得到服务
  >

  > 抢占式版本的又称“最短剩余时间优先算法（SRTN）”
  >

  - 优点：平均等待时间和平均周转时间较短

    > 在注重响应时间的三个算法中是最短的
    >
  - 缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。
- <u>高响应比优先（HRRN）</u>：**响应比**最高的作业/进程优先得到服务（非抢占）

  > **等待时间**长、**运行时间**短的优先得到服务
  >

  > $响应比=\frac{等待时间}{要求服务时间}+1$
  >

  - 优点：综合考虑了等待时间和运行时间，避免短作业长时间等待和长作业饥饿的问题

---

#### *注重响应时间的调度算法：*

> 更适应于交互式系统

- <u>时间片轮转调度算法（RR）</u>：按照到达顺序（就绪队列）**轮流**让**各进程**执行一个时间片，未执行完则重新放到队列尾排队（抢占）

  - 优点：公平；**响应快**，适用于**分时操作系统**
  - 缺点：高频率进程切换，开销较大；无法区分任务**紧急程度**
  - 时间片大小问题：

    - 时间片过大：增大进程**响应时间**，可能退化为 FCFS
    - 时间片过小：进程切换过于频繁，增大开销
- <u>优先级调度算法</u>：选择**优先级最高**的作业/进程（抢占、非抢占）

  - 优点：可区分紧急程度和重要程度，适用于**实时操作系统**。
  - 缺点：低优先级可能饥饿

  > 设置优先级的例子：
  >
  > - **系统**进程高于用户进程
  > - **前台**进程高于后台进程
  > - **I/O繁忙**型（I/O密集型）进程高于计算型（CPU密集型）进程
  >
  >   > I/O设备和CPU可以并行，优先让I/O繁忙设备运行，可以让I/O设备更早投入工作，提升资源利用率和系统吞吐量
  >   >
  > - **等待时间长**或刚运行不久的进程优先级较高
  > - 运行时间长的进程或刚运行完的进程优先级较低
  >
- <u>多级多反馈队列调度算法</u>：（抢占）

  - 算法规则
    - 设置多级就绪队列，**优先级**从高到低，**时间片**从小到大
    - 新进程先进入**高优先级**队列，用完时间片进入**次高优先级**队列，若已经是最低优先级则回到队尾
    - 高优先级队列为空时才会给次高优先级分配时间片
  - 优点：
    - 公平（FCFS的优点）
    - 短进程周转时间小（SPF的优点）
    - 响应快（RR的优点）
    - 可设置优先级
  - 缺点：会导致饥饿

> **进程调度时间计算**类问题通用解法：**广义甘特图**
>
> - 横轴：时间
> - 纵轴：各进程

### 2.3 进程互斥与同步

#### *互斥同步的概念与实现：*

- <u>概念</u>

  - <u>临界资源</u>：一次仅允许有一个进程使用的共享资源
  
      >   公用队列？
  
  - <u>临界区</u>：并发进程访问**临界资源**的**代码段**
  
  - <u>同步</u>：亦称**直接制约**关系，是指多个进程需要**协调工作次序**而产生制约关系。
  
  - <u>互斥</u>：亦称**间接制约**关系。是指多个进程**对临界资源的访问是互相排斥**的。
  
- <u>实现原则</u>

  - 空闲让进
  - 忙则等待
  - 有限等待
  - 让权等待
  
- <u>软件实现</u>

  - <u>单标志法</u>：
      - 思想：每个进程进入临界区的权限由**其他进程在使用完临界区后**赋予
      - 缺点：可能违反“**空闲让进**”和“**有限等待**”，原因在于**给其他进程赋予权限**的进程可能长期不使用临界区；违反“让权等待”
  - <u>双标志先检查法</u>：
    - 思想：先**通过标记检查其他进程**是否要进入临界区，如果要则**循环等待**，之后再**标记自己**想进入临界区
    - 缺点：可能违反“**忙则等待**”，原因在于**“检查”和“上锁”**不是原子操作；违反“让权等待”
  - <u>双标志后检查法</u>：
      - 思想：先**标记自己**想进入临界区，再**通过标记检查其他进程**是否要进入临界区，如果要则**循环等待**
      - 缺点：可能违反“**空闲让进**”和“**有限等待**”，从而导致饥饿，原因在于**“上锁”和“检查”**不是原子操作；违反“让权等待”
  - Peterson算法
    - 思想：
        1.   标记自己**想进入**临界区
        2.   表示“**谦让**”：将**`turn`轮流标记**设置为其他进程
        3.   通过标记检查，如果有**其他进程想进**且没有**轮流标记**没有到自己，则等待
    - 优点：符合“空闲让进”、“忙则等待”、“有限等待”
    - 缺点：违反“让权等待”
  
- <u>硬件实现</u>

  - <u>中断屏蔽</u>：
      - 思想：在访问临界区前后**关开中断**，避免**进程切换**
      - 优点：简单高效
      - 缺点：不适用于多处理机；需要开关中断指令需要运行在**内核态**
  - <u>TestAndSet指令（TS、TSL）</u>：
      - 思想：访问临界区前**“上锁”并”检查“之前是否已经有锁**（这个操作由硬件完成，不可中断），若有则循环等待；**访问临界区后”解锁“**
      - 优点：实现简单；适用于多处理机（涉及到总线相关知识）
      - 缺点：违反“让权等待”，循环等待时会占用 CPU 循环执行 TSL 指令
  - <u>Swap指令（Exchange、XCHG）</u>：
      - 思想：将当前锁的状态`lock`换到自己手上（`old`），看`old`是否无锁，若有则循环等待；**访问临界区后”解锁“**
      - 优点：实现简单；适用于多处理机
      - 缺点：违反“让权等待”，循环等待时会占用 CPU 循环执行 XCHG 指令

#### *信号量机制与经典问题：*

- 信号量基础知识

  - 信号量：就是**表示某种系统资源数量**的变量。<0 ?
  - 原语：**执行时不可被中断**的特殊程序（由开中断、关中断实现）

    - wait和signal原语，相当于资源的“申请”和“释放”

      > 记录型信号量的wait原语内部有用到block原语，signal原语内部有用到wakeup原语
      >
  - 用于实现**进程互斥**：设置**互斥信号量**（mutex），在临界前后执行PV操作
  - 用于实现**进程同步**：设置**同步信号量**，前V后P
- 经典问题及其解决思路

  - 生产者与消费者问题

    - 互斥：缓冲区
    - 同步：缓冲区空时生产者先消费者后；缓冲区满时消费者先生产者后
  - 多生产者与消费者问题

    - 互斥：缓冲区
    - 同步：缓冲区空时先生产某种产品对应消费者才能消费；缓冲区满时先消费才能生产
  - 吸烟者问题

    - 特点：有可以生产**多种产品**的单生产者、有“轮流”的要求
    - 互斥：桌子（可以不设置）
    - 同步：桌子空时先放才能拿；桌子满时先拿才能放
  - 读者-写者问题

    - 特点：读写互斥但读之间不互斥
    - 写-写互斥：rw锁
    - 写-读互斥：rw锁
    - 读-读不互斥：第一个来读的加锁，最后一个读完的解锁

      > 根据count变量加解rw锁，并通过mutex锁保证对count的更改和判断是不可中断的
      >
    - 读-写公平：再加一个w锁约束读进程**对count的检查和对rw锁的加锁**
  - 哲学家进餐

    - 特点：构造出了经典的**循环等待**场景
    - 互斥：同一根筷子
    - 防止死锁：让哲学家**拿起一双筷子的操作是原子性的**

#### *管程：*

- 管程的<u>概念</u>

  - 管程是一种特殊的**软件模块**，由**共享数据结构**和**对数据结构的操作（函数）**组成。
- 管程的<u>特点</u>

  - 管程**每次只允许一个进程**执行对数据结构进行**操作**

    > 只能通过**管程内部定义的过程/函数**来操作
    >
- 管程的<u>实现</u>

  - 互斥特性由**编译器**负责实现
  - 同步特性由**条件变量**和**等待唤醒操作**实现

#### *死锁*：

*概念：*

- 在并发环境下，各进程因**竞争资源**而造成的一种<u>互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进</u>的现象

---

*死锁的产生：*

- 必要条件

  - **互斥**条件：争抢互斥使用的资源
  - **不剥夺**条件：进程已经占有的资源在使用完之前不能被其他进程抢走
  - **请求和保持**条件：进程**请求新资源**的同时**保持原占有资源**不放
  - **循环等待**条件：存在进程资源的循环等待链

    > 前三点很多场景都满足，第四点是判断的重点
    >
- 发生时机

  > 对不可剥夺资源的不合理分配可能导致死锁
  >

  - 对系统资源的竞争
  - 进程推进顺序非法
  - 信号量的使用不当

---

*死锁的处理策略：*

> - 忽略
> - 检测与解除
> - 避免
> - 预防
>
>> 按系统并发性从大到小排序的4类处理策略
>>

- <u>**预防**死锁</u>

  - 破坏**互斥**条件：把互斥资源改造成共享使用（如SPOOLing技术）

    - 缺点：可行性不高，很多时候**无法破坏互斥条件**
  - 破坏**不剥夺**条件：

    - 方案一：申请的资源得不到满足时，立刻释放占有的所有资源
    - 方案二：申请的资源被其他进程占用时，由操作系统协助剥夺

      > 考虑优先级
      >
    - 缺点：实现复杂；剥夺资源可能导致部分工作失效；反复申请和释放导致系统开销大；可能导致饥饿
  - 破坏**请求和保持**条件：运行前分配好所有需要的资源（**静态分配**），一直保持直到运行结束

    - 缺点：资源利用率低；可能导致饥饿
  - 破坏**循环等待**条件：给**资源编号**，按编号从小到大的顺序申请资源（顺序资源分配）

    > 原理：已经持有大编号资源的进程不可能回来申请小编号的资源。任意时候总有一个进程拥有的资源编号最大，那么从该进程出发一定有**安全序列**，也就是任意时刻都有安全序列。
    >

    - 缺点：不方便增加新设备；进程使用资源的顺序与编号顺序可能不同，导致资源浪费；用户编程麻烦（必须按编号顺序申请资源），程序可移植性差。
- **避免**死锁

  - 银行家算法思想：在进程申请资源时，预判这次分配后会不会进入**不安全状态**，如果会则阻塞进程

    - 不安全状态：找不到安全序列
    - 安全序列：系统按照这个序列分配资源，则每个进程都能顺利完成
  - 银行家算法步骤

    1. 检查此次申请$Request$是否超过之前声明的**最大需求数**$Need$，如果超过认为**出错**

       > $Need=Max-Allocation$
       >
    2. 检查系统剩余可用资源$Available$是否能**满足这次请求**$Request$，不能则**阻塞进程**
    3. **试探分配**，更改数据结构
    4. 用**安全性算法**检查分配后是否会导致系统进入不安全状态
  - 安全性算法步骤

    - 检查当前剩余可用资源$Work$是否能满足某个（某些）进程的最大需求，如果可以则将该进程（这些进程）加入**安全序列**，并回收其全部资源
    - 重复上述过程，直至找到完整的**安全序列**或$Work$无法满足现有的任何进程
- 死锁的**检测**：

  - 能检测的前提：
    - 有某种**数据结构**保存资源的**请求和分配信息**
    - 有一种检测系统是否进入死锁状态的**算法**
  - 数据结构：资源分配图
    - **进程**结点：对应一个进程
    - **资源**结点：对应一类资源，结点中可以记录该类资源**总量**
    - **进程**结点指向**资源**结点的边：进程**还需要**申请的资源（每条边代表一个）
    - **资源**结点指向**进程**结点的边：已经分配给进程的资源（每条边代表一个）
  - 算法：如果某时刻系统的资源分配图是**不可完全简化**的，那么此时系统死锁（死锁定理）
    - **能执行**的进程（已申请到**所有所需资源**）或能**分配现有资源**使之**能执行**的进程先执行，执行完后归还系统资源，消除相应的边
    - 继续寻找能执行的进程，直到不再能找到或消除了所有的边
    - 如果能消除所有边，就称该资源分配图是可完全简化的
- 死锁的**解除**

  - 资源剥夺
  - 撤销进程
  - 进程回退

## 3 内存管理

### 3.1 内存管理概述

#### *内存和地址概述：*

- <u>内存概述</u>

  - 概念：内存是用于**存放数据的硬件**。
  - 主要应用：程序要放到**内存**中才能被**CPU**直接执行。
  - 组织形式：内存通常从0开始顺序编址，每号地址对应一个存储单元

    - 按字节编址：每个存储单元大小为1字节
    - 按字编址：每个存储单元大小为1个字

      > 字长由计算机决定
      >
- <u>地址与地址空间概述</u>

  - 虚拟地址：用户编程时使用的地址，一般指**段名+段内相对地址**
  - 逻辑地址/相对地址：用户编程时使用的地址，一般指**段内相对地址**
  - 物理地址/绝对地址：实际物理内存的地址
  - 逻辑地址空间：一般指各**程序段**所有**逻辑地址**的集合

    > 实际应用中，虚拟地址与逻辑地址常常不加区分
    >
  - 线性地址空间：**CPU地址总线**可以访问的所有地址集合
  - 物理地址空间：实际可访问的**物理内存地址**集合
- <u>编译、链接、装入</u>

  - 概念

    - 编译：<u>编译程序</u>将**用户源代码**编译成若干个**目标模块**

      > 编译时会形成相对该模块的逻辑地址
      >
    - 链接：<u>链接程序</u>将各目标模块、**库函数**链接在一起，形成的**装入模块**

      > 装入模块就是一种**可执行模块/文件**
      >
      > 链接器完成重定位，形成整个程序完整的逻辑地址空间
      >
    - 装入：<u>装入程序</u>将装入模块装入内存运行
  - 链接的三种方式

    - 静态链接：在**程序运行前**将各目标模块、库函数链接成**完整的装入模块**
    - 装入时动态链接：在各目标模块**装入内存时**链接库函数
    - 运行时动态链接：程序**运行时需要**目标模块再链接库函数

      > 便于库函数的**修改和更新**，便于目标模块的**共享**
      >
  - 装入的三种方式

    - 绝对装入：直接按照编译时产生的**绝对地址**将程序和数据装入内存

      > 绝对装入只适用于**单道程序环境**
      >
    - 静态重定位：又称可重定位装入，指令和数据使用**逻辑地址**，由**装入程序**在装入时完成逻辑地址到**物理地址**的转换

      > 静态重定位装入时必须分配**全部所需空间**，模块装入内存后，运行期间**无法申请其他内存、无法移动**
      >

      > 用于早期**多道批处理系统**
      >
    - 动态重定位：又称动态运行时装入，指令和数据使用**逻辑地址**，在程序**运行时**借助**重定位寄存器**完成逻辑地址到**物理地址**的转换

      > 重定位寄存器/基址寄存器：存放装入模块的**起始物理地址**
      >

      > 动态重定位允许**分配不连续内存**，允许动态地**部分装入和申请内存**，允许模块**在内存中移动**，便于**共享和虚拟内存**的实现
      >

---

#### *内存管理的主要内容：*

- <u>内存的分配与回收</u>：操作系统负责**内存空间的分配与回收**

  - 连续分配

    - 单一连续分配
    - 固定分区分配
    - 动态分区分配
  - 非连续分配

    - 基本分页存储管理
    - 基本分段存储管理
    - 基本段页式存储管理
- <u>内存空间的扩充</u>：操作系统需要提供某种技术从逻辑上**对内存空间进行扩充**

  - 覆盖技术
  - 交换技术
  - 虚拟存储技术
- <u>地址转换</u>：操作系统需要提供**地址转换功能**，负责程序的**逻辑地址**与**物理地址**的转换
- <u>存储保护</u>：操作系统需要提供**内存保护**功能，保证各进程在各自存储空间内运行，互不干扰

  - 采用**上下限寄存器**，存放进程的**上下限地址**
  - 采用**基址寄存器和界地址寄存器**，分别存放**起始物理地址**和**最大逻辑地址**

    > 基址寄存器也称**重定位寄存器**，界地址寄存器也称**限长寄存器**
    >

### 3.2 连续分配与地址转换

> 连续分配：为用户进程分配的只能是**连续的内存空间**

#### *单一连续分配：*

- <u>内存划分</u>：单一连续分配方式中内存被分为**系统区和用户区**

  - 系统区：位于内存的低地址部分，存放**操作系统相关数据**
  - 用户区：存放**用户进程相关数据**，只允许**一道用户程序独占**整个用户空间
- <u>单一连续分配的优点</u>：

  - 实现简单
  - 无外部碎片
  - 可以用覆盖技术扩充内存
  - 不一定需要内存保护
- <u>单一连续分配的缺点</u>：

  - 只能用于单用户、单任务操作系统
  - 有内部碎片

    > 内部碎片：分配给进程的内存空间中没有被利用的部分
    >
  - 存储器利用率极低

---

#### *固定分区分配：*

- 将整个用户空间划分为若干个**固定大小的分区**，每个分区中装入一道作业，支持**多道程序**并发
- <u>分区**策略**</u>：
  - 分区大小相等：缺乏灵活性，适合用于一台计算机控制多个相同对象的场合
  - 分区大小不等：增加了灵活性，可以根据不同大小的进程需求划分空间
- <u>**分区说明表**</u>：用于管理分区，记录各分区的分配与回收
  - 字段：分区号、分区大小、起始地址、状态（已分配和未分配）
- <u>固定分区分配**优缺点**</u>：
  - 优点：实现简单，无**外部碎片**
  - 缺点：
    - 可能无法满足**大进程**需求，不得不采用低性能的**覆盖**技术
    - 会产生**内部碎片**，内存利用率低

---

#### *动态分区分配：*

- 又称为**可变分区分配**，不预先划分内存分区，而是在进程装入内存时**根据进程大小动态建立分区**，因此系统分区的**大小和数目是可变的**。
- <u>分区分配中的**数据结构**</u>

  - 空闲分区表：
    - 字段：分区号、分区大小、起始地址、状态（已分配和未分配）
  - 空闲分区链：
    - 将每个单独的内存分区视作链表的一个结点
    - 结点的起始部分：前向指针、分区大小等信息
    - 结点的末尾部分：后向指针
- <u>分配与回收的**具体操作**</u>

  - 分配：根据分配算法选择空闲区，再**更新空闲分配表**
    - 只**占用部分**空闲区：**修改**表项
    - 刚好**填满**空闲区：**删除**表项
  - 回收：回收进程并**更新空闲分配表**
    - 有相邻空闲分区：
      - 只有前面有或只有后面有：修改表项
      - 前后均有：合并表项
    - 无相邻空闲分区：
      - 新增表项
- **<u>动态分区分配算法</u>**：

  - 首次适应算法（First Fit）

    - 思想：从**低地址向高地址**查找第一个满足大小的空闲分区
    - 实现：空闲分区表以**地址递增**次序排列，每次分配时顺序查表
    - 优点：综合性能好；对空闲分区表操作简单，**算法开销小**；可以保留高地址部分大空闲区
    - 缺点：低地址部分易产生**外部碎片**
  - 最佳适应算法（Best Fit）

    - 思想：优先使用**更小的空闲区**分配
    - 实现：空闲分区表按**容量递增**次序链接，每次分配时顺序查表
    - 优点：保留更多**大空闲区**，满足大进程需求
    - 缺点：容易残留更多**外部碎片**；回收分区后要**排序**空闲分区表，**算法开销大**
  - 最坏适应算法（Worst Fit）

    - 思想：优先使用**更大的空闲区**分配
    - 实现：空闲分区表按**容量递减**次序链接，每次分配时顺序查表
    - 优点：可以减少**外部碎片**
    - 缺点：难以保留**大空闲区**，不利于大进程需求；回收分区后要**排序**空闲分区表，**算法开销大**
  - 邻近适应算法（Next Fit）

    - 思想：在**首次适应**算法的基础上，每次从**上次查找结束**位置开始**循环查找**
    - 实现：空闲分区表以**地址递增**次序排列成**循环表**，每次分配时**从上一次位置开始循环查表**
    - 优点：对空闲分区表操作简单，**算法开销小**；减少低地址部分的**外部碎片**
    - 缺点：难以保留**大空闲区**，不利于大进程需求
- <u>动态分区分配的**优缺点**</u>

  - 优点：无**内部碎片**，分配出的内存利用率高
  - 缺点：有**外部碎片**，会产生过小的空闲分区而难以分配

    > 可以通过**紧凑（拼凑，Compaction）**技术解决外部碎片，这需要结合**动态重定位装入**移动进程块位置，并修改PCB中的进程起始地址，以及重定位寄存器/基址寄存器
    >

### 3.3 分页分段与地址转换

> 离散分配：为用户进程分配的可以是**分散的内存空间**

#### *基本分页存储管理：*

```
基本分页存储管理
	- 基本思想
	- 页表与地址结构
	- 地址变换机构
```

- <u>基本思想</u>：把**内存**划分成相等的**分区**，再按照同样大小将**进程**拆分成**进程块**

  - 划分出的内存分区称为**页框**，或页帧、内存块、物理块；

    每个页框都有编号，称为**页框号**，或页帧号、内存块号、物理块号
  - 与页框大小相等的进程块称为**页**或页面；

    每个页都有编号，称为**页号**

  > 进程被拆分的最后一个页面可能小于页框大小，因此页框不能太大，否则会产生过大的**内部碎片**。但这种方式一定不会产生**外部碎片**。
  >
- <u>页表与地址结构</u>

  - 页表：操作系统为每个进程建立一张页表，记录**进程每个页面在物理内存中的内存块号**

    > 页表本身也存储于内存，单级页表**顺序存储**，多级页表可以**离散存储**
    >
  - 页表项：每个页表项**长度相等**，由页号和块号组成

    - 页号：进程页号，隐含的，相当于逻辑上的数组**索引**
    - 块号：进程页实际存放到的**内存块号**。其位数由**内存块的数量**决定

    > **页表项的大小**尽量能整除页框大小，这样存放页表时可以减少**内部碎片**
    >
  - 逻辑地址结构：

    - **页号P**：逻辑地址所在页的**页号**。页号=逻辑地址/页面长度

      利用**页表**，以页号作为**索引**，查寻块号，计算出进程页在内存中的**起始地址**

      页号P的位数对应于进程的**最大页面数**
    - **页内偏移量W**：逻辑地址在页内的**偏移量**。页内偏移量=逻辑地址%页面长度

      页内偏移量W的位数对应于**页面大小**

    > 页式管理中地址是**一维**的，程序员只要给出**一个逻辑地址助记符**就可以自动计算出**物理地址**
    >
  - **多级**页表/页目录表：将页表**拆分并离散存放**至内存，并用页目录表统计

    > 单级页表需要**连续存储**至内存，不符号离散分配的思想
    >

    - 页目录表的表项：

      页号：某级页号

      块号：“页表块”存放到的内存块号
    - 对应的逻辑地址结构：

      页号：可被拆分成多级页号

      页内偏移量：与单级页表相同
    - 多级页表的思想在虚拟存储技术中有所应用
  - **快表**：又称联想寄存器（TLB, Translation Look-aside ），是一种**高速缓存**，用于存放最**近访问过的若干页表项**，以加速地址变换。相对而言，内存中的页表常称为**慢表**

    > 单级页表记录了所有页的信息，没有考虑**局部性原理**
    >

    > 快表具体的结构与算法参见计算机组成原理
    >
- <u>地址变换机构</u>

  - 页表寄存器（PTR）

    - 存放页表在内存中的**起始地址F和页表长度M**
    - F和M会存放于PCB中，在进程执行时存入PTR
  - 地址变换过程

    1. 根据逻辑地址算出**页号P、页内偏移量W**
    2. 根据**页号**得到**进程页起始地址**

       0. （**匹配快表**：若命中快表表项，可直接得到**进程页起始地址**，若未命中则需**访存**）
       1. **越界检查**：将**页号**与PTR中的**页表长度**对比，检查是否合法
       2. **索引计算**：根据**页表起始地址、页表项长度、页号**计算出**页表项地址**

          > 这也是**数组**索引访问的计算原理
          >
       3. **得到始址**：由页表项得到进程页所在**内存号块**，进而计算出**进程页起始地址**
       4. （**更新快表**：将页表项存入快表）
    3. 根据**进程页起始地址和页内偏移量**计算出**物理地址**
  - 页表与访存：

    - 在没有命中快表的情况下：n级页表的访存次数为n+1次，前n次是查找页表，最后一次是访问数据

      > 不考虑多级快表
      >
    - 在命中快表的情况下：只需一次访问内存数据（查询快表访问的是缓存）

---

#### *基本分段存储管理：*

```
基本分页存储管理
	- 基本思想
	- 段表与地址结构
	- 地址变换机构
```

- <u>基本思想</u>：

  - 进程按**逻辑**关系划分为若干个大小可以不相等的**段**，每段都有一个**段名和段号**，从0开始编址

    > 编程更方便，程序可读性更高
    >
  - 以段为单位分配内存，段内连续，各段之间可以离散
- <u>段表与地址结构</u>：

  - 段表：操作系统为每个进程建立一张段映射表，记录各**逻辑段在物理内存中存放位置**
  - 段表项

    - 段号：进程逻辑段的段号，隐含的，相当于逻辑上的数组**索引**
    - 段长：逻辑段的长度。位数与**段内地址**位数相同。
    - 逻辑段基址：逻辑段在物理内存中存放的**起始位置**。位数由物理内存**存储单元个数**决定
  - 逻辑地址结构：段号+段内地址

    - 段号：逻辑地址所在段的段号。段号=逻辑地址/最大段长

      段号的位数对应于进程最多可以分几个段
    - 段内地址：逻辑地址在段内的偏移量。段内地址=逻辑地址%最大段长

      **段内地址**位数决定了最大**段长**

    > 段式管理中地址是**二维**的，程序员要同时给出**段名和段内地址**才可以计算出**物理地址**
    >
- <u>地址变换机构</u>：

  - 段表寄存器：
    - 存放段表在内存中的**起始地址F和段表长度M**
    - F和M会存放于PCB中，在进程执行时存入段表寄存器
  - 地址变换过程：
    1. 根据逻辑地址算出**段号、段内地址**
    2. 根据**段号**得到**进程逻辑段起始地址**
       1. **越界检查**：将**段号**与段表寄存器中的**段长度**对比，检查是否合法
       2. **索引计算**：根据段表起始地址、段表项长度、段号计算出**段表项地址**
       3. **越界检查**：由段表项得到**段长**，检查**段内地址**是否合法
       4. 得到始址：由段表项**进程逻辑段起始地址**
    3. 根据**进程逻辑段起始地址和段内地址**计算出**物理地址**
  - 段表与访存：
    - 一次访存查段表，一次访存目标数据
    - 也可以引入快表减少访存
- <u>分段分页对比</u>：

  - 从地址空间的角度对比：
    - 页是信息的**物理单位**，对用户不可见，分页进程的地址空间是一维的。页长固定，由系统决定。
    - 段是信息的**逻辑单位**，对用户可见，分段进程的地址空间是二维的。段长不固定，由程序员决定。
  - 从目的的角度对比：
    - 分页目的是实现**离散分配**，提高内存利用率，是系统管理的需要。没有外部碎片，会产生少量页内碎片。
    - 分段目的是将进程划分为逻辑段，方便程序员编程。会产生外部碎片，且段长过大不方便分配
  - 从共享的角度对比：
    - 分段可以拆分逻辑模块，比分页更容易实现**信息的共享和保护**。
    - 分段可以灵活拆分**可重入代码和不可重入代码**，保证**数据一致性**，实现安全共享。分页则不够灵活。

---

#### *段页式存储管理：*

```
基本分页存储管理
	- 基本思想
	- 段表、页表与地址结构
	- 地址变换机构
```

- <u>基本思想</u>：

  - 先将进程拆分成**逻辑段**，再将各**逻辑段分页**。分段对用户可见，分页对用户不可见。
  - 在**用户进程**这边，保留**段的逻辑划分**；在**系统内存**这边，保留**页的管理方式**。
- <u>段表、页表与地址结构</u>：

  - 逻辑地址结构：

    - 段号：逻辑地址所在段的段号。段号=逻辑地址/最大段长

      段号的位数对应于进程**最多可以分几个段**

      > 保留分段存储管理的**段号**，将**段内地址**拆分成页号和页内偏移量。
      >
      > 段内地址=逻辑地址%最大段长
      >
    - (段内)页号：逻辑地址在**段内所在页**的页号。(段内)页号=段内地址/页面长度

      (段内)页号的位数对应于**每个段最多有多少页**
    - 页内偏移量：逻辑地址在**段内所在页**中的偏移量。页内偏移量=段内地址%页面长度

      页内偏移量的位数对应于**页面大小**

    > 段页式管理中地址是**二维**的，程序员要同时给出**段名和段内地址**才可以计算出**物理地址**
    >
  - 段表与页表结合：

    - 段表项：段表项的内容是**页表信息**

      段号：逻辑地址所在段号，隐含的，相当于逻辑上的数组索引

      页表长度：逻辑段的页表的长度。位数与(段内)页号的位数相同

      页表块号：逻辑段的页表实际存放到的内存块号，其位数由**内存块的数量**决定
    - 页表项：页表变化不大，但一个进程可以有多个页表

      页号：逻辑段页号，隐含的，相当于逻辑上的数组**索引**

      块号：逻辑段页实际存放到的**内存块号**。其位数由**内存块的数量**决定
  - 段页表与访存
- <u>地址变换机构</u>：

  ```mermaid
  graph LR
  逻辑地址-->段号
  逻辑地址-->页号
  逻辑地址-->页内偏移量
  段号--段表-->页表-->基址
  页号--页表-->基址
  基址-->物理地址
  页内偏移量--基址-->物理地址
  ```

  - 段表寄存器
    - 存放段表在内存中的**起始地址F和段表长度M**
    - F和M会存放于PCB中，在进程执行时存入段表寄存器
  - 地址变换过程
    1. 根据逻辑地址算出**段号、页号、页内偏移量**
    2. 根据**段号、页号**得到**进程逻辑段页起始地址**
       1. **段号越界检查**：将**段号**与段表寄存器中的**段长度**对比，检查是否合法
       2. **段表项索引计算**：根据段表起始地址、段表项长度、段号计算出**段表项地址**
       3. **页号越界检查**：由段表项得到**页表长度**，检查**(段内)页号**是否合法
       4. **得到逻辑段页表始址**：由段表项得到逻辑段页表所在**内存块号**，进而计算出逻辑段页表起始地址
       5. **页表项索引计算**：由逻辑**段页表起始地址、页表项长度、逻辑段页号**计算出**页表项地址**
       6. **得到逻辑段页始址**：由页表项得到逻辑段页所在**内存号块**，进而计算出**逻辑段页起始地址**
    3. 根据**进程逻辑段页起始地址和页内偏移量**计算出**物理地址**
  - 段页表与访存
    - 一次查段表，一次查页表，一次访问目标单元
    - 可引入快表减少访存

### 3.4 覆盖交换和虚拟存储

#### *覆盖和交换技术：*

<u>覆盖技术</u>：

- 基本思想：将程序分为多个段，**常用的段常驻内存**，不常用的段在需要时调入内存且**互相覆盖**
- 实现方式：将内存分为固定区和覆盖区，并合理划分程序的**调用结构**

  - **固定区**：常驻内存的段放在固定区，调入后直接程序结束才调出。

    在调用结构中位于顶层的模块**独占固定区**
  - **覆盖区**：不常用的段在用到时调入覆盖区，用不到时调出

    在调用结构中位于同一层次但不会同时调用的模块**共享覆盖区**
- 优缺点：

  - 优点：实现了内存扩充，提高内存利用率和运行效率
  - 缺点：必须由程序员**声明覆盖结构**，操作系统完成自动覆盖，对用户不透明，增加编程负担

<u>交换技术</u>：

- 基本思想：**进程的中级调度/内存调度**，将内存中暂时无法运行的进程**换至外存**，把外存中具备运行条件的进程**换入内存**
- 实现方式：

  - 磁盘分为文件区和对换区：

    **文件区**存放文件，追求**存储空间的利用率**，因而采用**离散分配**；

    **对换区**只占磁盘空间的小部分，用于存放换出的进程数据，追求**换入换出速度**，因而采用**连续分配**
  - 交换调度策略：

    **交换时机**：系统负荷大、内存空闲不足时，例如进程经常发生缺页现象时

    **调度策略**：可换出阻塞进程、优先级低的进程，为防止抖动，还可以考虑进程在内存驻中的留时间……

  > 注：进程的**PCB一定常驻内存**，内存调度时不会被换出
  >
- 覆盖与交换的区别

  - 覆盖是在**同一个进程**中的
  - 交换是在**不同进程（或作业）**中的

---

#### *虚拟内存的思想：*

:star:<u>传统存储管理方式的特点</u>：

- **一次性**：作业必须**一次性全部装入**内存才开始运行

  - 容易导致**大作业无法运行**
  - 内存无法容纳太多作业，**多道程序并发度下降**
- **驻留性**：作业装入内存后会**一起驻留直到运行结束**

  > 事实上只要访问一小部分数据就可以正常运行
  >

  - 内存中会驻留许多暂时用不到的数据，**降低内存的利用率**

:star:<u>虚拟内存的定义和特征</u>：

- 虚拟内存的概念：程序装入内存时，可以只装入运行**需要用到的模块**，暂时用不到的模块可以换出至外存，待需要时再调入内存，这样在用户看来就似乎有一个比实际内存更大的内存

  > 是内存在逻辑上的扩充，体现了**操作系统的虚拟性**
  >
- 虚拟内存的特征：

  - 多次性：允许作业分多次调入内存
  - 对换性：作业无需常驻内存，允许根据需求换入换出
  - 虚拟性：从逻辑上扩充了内存容量

---

#### *虚拟内存的实现：*

> 虚拟内存的要在**离散分配**方式的基础上实现，分页分段均可，下面以分页为例

:star:<u>请求调页</u>：

- <u>页表机制</u>

  > 在基本分页存储管理页表的基础上，添加四个新的字段
  >

  - **状态位**：是否已经调入内存
  - **访问字段**：可记录最近被访问的次数，或上次访问的时间，供置换算法参考
  - **修改位**：页面调入内存后是否被修改过
  - **外存地址**：页面在外存中的存放位置
- <u>缺页中断机构</u>

  - 缺页中断的概念：进程当前指令**访问的目标页未调入内存**而产生的中断，属于**内中断**中的故障（fault）
  - 工作流程：
    1. 找到页表项后检查**状态位**，若页面未调入内存则产生**缺页中断**，阻塞当前进程
    2. 运行操作系统的**缺页中断处理程序**，将目标页面调入内存并更新**页表**
       1. 保留CPU现场
       2. 从外存中找到缺页
       3. 若内存中没有空闲块，则需要运行**页面置换**算法淘汰一个页面；若被调出的页面修改过，还需要**写回外存**
       4. CPU读入缺页，将缺页调入内存
       5. 更新页表和快表
    3. **唤醒**因缺页中断阻塞的进程，放入**就绪队列**，让其重新查表
- <u>地址变换机构</u>：总体上与基本分页存储管理相同，增加了几个步骤

  - 请求调页：访问页表时若发现页不在内存，要产生缺页中断请求调页
  - 页面置换：调入前若发现内存没有空闲块，需要进行页面置换
  - 修改页表：调入缺页后修改页表，并即时增加或删除快表

:star:<u>页面置换</u>：

- <u>页面置换算法</u>

  - 最佳置换算法（OPT，Optimal）

    - 算法思想：每次淘汰**之后最长时间内不再被访问**的页面
    - 算法实现：需要提前知道页面访问序列，淘汰时计算内存中各页面下一次出现的位置，最后一个出现的被淘汰
    - 算法评价：可以保证最低的缺页率。但该算法无法实现，因为操作系统无法预判**页面访问序列**
  - 先进先出置换算法（FIFO）

    - 算法思想：每次淘汰**最早调入内存**的页面
    - 算法实现：将调入内存的页面按调入顺序排成队列，每次淘汰队头页面

      > 队列的最大长度取决于操作系统为进程分配了多少个内存块
      >
    - 算法评价：实现简单；会产生Belady异常，没考虑局部性原理，性能差

      > Belady异常：为进程分配的内存块数增加时，**缺页次数不减反增**
      >
  - 最近最久未使用置换算法（LRU，least Recently Used）

    - 算法思想：每次淘汰最近最久未使用的页面
    - 算法实现：用页表项的访问字段记录**自上次被访问以来所经历的时间t**，每次淘汰t值最大的页面

      > 做题时可以从当前访问页开始逆向检查访问序列，最后一个出现的就是要淘汰的
      >
    - 算法评价：性能好；实现困难，需要专门的硬件支持，开销大

      > 性能最接近OPT
      >
  - 时钟置换算法/最近未用算法（NRU，Not Recently Used）/CLOCK算法

    - 简单CLOCK算法的实现：

      将内存中的页面链接成一个循环队列，某页被访问时，将其页表项的访问位置1；

      需要淘汰页面时，从上一次淘汰的位置或其下一个位置开始，遍历队列循环检查访问位，若为0则直接换出，若为1则将其置为0；

      这样最多两轮扫描，就可以淘汰一个页面
    - 改进CLOCK算法的实现：

      > 思想：在近期访问情况相近的情况下，优先淘汰**没有修改**的页面，以减少IO次数
      >

      将内存中的页面链接成一个循环队列，某页被访问时，将其页表项的访问位置1，某页被修改时，将其页表项的修改位置1，初始为0，用$(访问位,修改位)$表示各页面状态。

      需要淘汰页面时，从上一次淘汰的位置或其下一个位置开始，遍历队列循环检查$(访问位,修改位)$：

      第一轮寻找第一个$(0,0)$，找到则替换，不修改标志位；

      第二轮寻找第一个$(0,1)$，找到则替换，将扫描过的访问位置为0；

      第三轮寻找第一个$(0,0)$，找到则替换，不修改标志位；

      第四轮寻找第一个$(0,1)$，找到则替换。

      这样最多四轮扫描，就可以淘汰一个页面
    - 算法评价：开销小，性能不错
- <u>页面置换策略</u>

  - **驻留集**：请求分页存储管理中给进程分配的物理块的集合

    - 在虚拟存储中，驻留集大小一般小于进程总大小
    - 若驻留集太小，会导致缺页频繁；若驻留集太大，会降低多道程序并发度
  - 页面分配与置换方式

    - **固定分配**：进程运行期间驻留集大小不变
    - **可变分配**：进程运行期间驻留集大小可变
    - **局部置换**：进程缺页时只能置换属于自己的物理块（由操作系统分配的）
    - **全局置换**：进程缺页时可以利用操作系统的空闲块，也可以窃取其他进程的物理块
  - 三种置换策略

    - **固定分配局部置换**

      可以根据**进程优先级**等信息分配内存块数

      > 缺点：很难确定合理的分配数
      >
    - **可变分配全局置换**

      操作系统维护一个**空闲物理块队列**，进程缺页时可分配。

      空闲物理块不足时，只能窃取其他进程**未锁定**的物理块
    - **可变分配局部置换**

      若进程频繁缺页，操作系统可以为该进程分配更多物理块，直至**缺页率**适当；

      若进程几乎不缺页，操作系统可以剥夺该进程的物理块
  - 调入页面的时机

    - 预调页：根据局部性原理，在进程首次调入时预测其他可能访问到的页面

      > 目前的技术预测成功率只有50%左右
      >

      > **运行前**调入
      >
    - 请求调页：进程运行期间缺页时才调入，或操作系统检查到进程缺页率较高时调入

      > **运行时**调入
      >
  - 调入页面的地点

    - 系统有足够对换区：

      提前将数据从文件区复制到对换区，内存与对换区之间调入调出页面

      > 保证调入调出速度快
      >
    - 系统对换区不充足：

      不会被修改的数据直接从文件区调入内存，可能会修改的数据从对换区调入调出
    - UNIX方式：

      未使用过的页面都从文件区调入，使用过后从对换区调入调出
  - 抖动现象与工作集：

    - 抖动现象描述：刚换出内存的页面马上又要换入，或刚换入内存的页面马上又要换出
    - 抖动现象产生原因：驻留集小于工作集
    - 工作集：在某段时间内，进程实际访问过的**页面集合**

      > 可以通过“窗口尺寸”来确定一段时间，即从页面访问序列的当前位置向前看“窗口尺寸”个页面。这符合局部性原理，也可以据此设计一种页面置换算法
      >
    - 抖动现象解决方案：保证驻留集大于工作集，即增大驻留集或减小工作集

## 4 文件管理

### 4.1 文件与目录概述

#### *文件概述：*

- <u>文件的概念</u>：文件就是一组**有意义的信息/数据**集合
- <u>文件的属性</u>：
  - 文件名：用户创建文件时决定的文件名，主要为了**方便用户找到文件**。**同一目录下不允许有重名文件**
  - 标识符：**操作系统**用于区分各个文件的内部名称。一个系统内各文件标识符唯一
  - 类型：指明文件的**类型**
  - 位置：文件存放的**路径**（让**用户**使用）；文件在**外存中的地址**（**操作系统**使用，对用户不可见）
  - 大小：指明文件的**大小**
  - 时间相关：创建时间、上次修改时间
  - 保护控制相关：文件所有者信息、保护信息（对文件进行保护的访问控制信息）
- <u>文件的组织</u>：
  - **无结构**文件：由一些**二进制或字符流**组成，又称”**流式**文件“
  - **有结构**文件：由一组**相似的记录**组成，又称”**记录式**文件“

    - **数据项**是文件系统中最基本的数据单位
    - **记录**是一组相关数据项的集合，**各记录间的组织问题**就是**文件的逻辑结构**问题
  - **文件之间的组织问题**就是**文件目录**要探讨的问题

---

#### *操作系统的文件管理概述：*

- <u>操作系统向上提供的**API**</u>：

  - 创建文件：`create`系统调用，在**外存**中创建文件
  - 读文件：`read`系统调用，将文件数据从**外存**读入**内存**，由**CPU**处理
  - 写文件：`write`系统调用，将文件数据从**内存**写回**外存**
  - 删除文件：`delete`系统调用，将文件数据从**外存**中删除
  - 打开文件：`open`系统调用，**读/写文件之前**需要做的操作
  - 关闭文件：`close`系统调用，**读/写文件之后**需要做的操作
- <u>操作系统向下对**磁盘的管理**</u>：

  - 磁盘块的存储与管理

    - 操作以”**块**“为单位为**文件**分配存储空间，以”**块**“为单位划分**外存**

      > ”**块**“的大小通常与内存页大小相同，通常为4KB
      >
    - 文件也具有**逻辑地址**，包括$<逻辑块号,块内地址>$，访问外存时需要转换为**物理地址**，即$<物理块号,块内地址>$
    - 文件在磁盘块上的存储问题就是**文件的物理结构**问题
- 文件共享与保护

  - 文件共享：使多个用户可以**共享使用一个文件**
  - 文件保护：如何保证不同的用户对文件有不同的**操作权限**

---

#### *文件目录：*

- <u>文件目录的概念</u>：

  - 文件目录就是**文件控制块**的有序集合，其本身也是一种有结构文件
  - 文件控制块（FCB）：FCB就是文件**目录项**，一个文件对应一个FCB，记录了各种文件信息
    - 基本信息：**文件名**、**物理地址**、结构、类型、...
    - 存储控制信息：是否可读写、用户访问权限
    - 使用信息：建立时间、修改时间
  - 目录的操作
    - **搜索目录**：搜索目录中的文件，即目录项FCB
    - **增加目录项**：创建新文件时需要在所属目录创建目录项
    - **删除目录项**：删除新文件时需要在所属目录删除目录项
    - **显示目录**：显示目录内容，例如其中所有文件的属性
    - **修改目录**：文件属性变化时需要修改相应目录项
- <u>目录结构</u>：

  - **单级**目录结构

    - 特点：整个系统只有一级目录表；实现**按名存取**；不允许任何文件重名
    - 缺点：不适用于多用户操作系统
  - **两级**目录结构

    - 特点：分为**主文件**目录（MFD，Master File Directory）和**用户文件**目录（UFD，User File Directory）；主文件目录记录**用户名**及用户文件目录**存储位置**；用户文件目录记录该用户的文件FCB；允许不同用户的文件重名
    - 优点：在目录上实现**用户访问限制**
    - 缺点：缺乏灵活性，用户不能对自己的文件**分类**
  - **多级/树形**目录结构

    - 特点：

      用**斜杠分隔的文件路径**标识文件，各级目录用斜杠隔开；

      **绝对路径**查找文件：从外存读入**根目录表**和其他涉及的**目录表**，需要多次磁盘I/O操作；

      **相对路径**查找文件：可以设置一个“**当前目录**”作为查找文件的起点，减少磁盘I/O操作

      > 为什么能减少？因为用户很可能**连续访问同一目录**的多个文件，此时**不必再次调入上级目录**就能直接访问
      >
    - 优点：层次结构清晰，可以对文件灵活分类管理
    - 缺点：不方便文件共享
  - **无环图**目录结构

    - 特点：在**树形**目录结构的基础上，可以让**不同文件名指向同一个文件结点**（有向无环图）；为每个文件结点设置**共享计数器**，减为0时才删除结点
    - 优点：方便地实现多用户间的文件共享
- <u>索引结点</u>：

  - 每个文件对应一个**索引结点**，存放除**文件名**之外的描述信息（包括文件在外存中的**存放位置**）
  - **目录项**只包含文件名、索引结点指针；目录项长度减少，占用的磁盘块减少，检索文件时磁盘I/O次数减少
  - **硬盘**索引结点与**内存**索引结点
    - 硬盘索引结点：存放在**外存**中的索引结点，在通过**目录项**索引到时才**调入内存**
    - 内存索引结点：调入内存的索引结点，相比于硬盘索引结点，需要增加

---

#### *文件系统层次结构：*

> 从“用户/应用程序”的调用开始，自顶向下介绍

- 用户接口：向上层用户提供功能接口，处理相关**系统调用**请求
- 文件目录系统：解析用户的文件路径，找到相应的**FCB或索引结点**。管理目录和目录项
- 存取控制系统：验证用户权限，完成**文件保护**相关功能
- 逻辑文件系统与文件信息缓冲区：将用户要访问的**文件记录号**转换为对应的**逻辑地址**
  - 文件信息缓冲区可用于存放调入内存的索引表
- 物理文件系统：将文件逻辑地址转换为**物理地址**
- 辅助分配模块和设备管理模块
  - 辅助分配模块：负责分配和回收**存储空间**
  - 设备管理模块：与**硬件**直接交互，负责硬件设备相关的管理工作

### 4.2 文件的结构

#### *文件的逻辑结构：*

- <u>文件逻辑结构概述</u>

  - 文件逻辑结构的含义：在**用户**看来文件的数据是如何组织的
  - 文件逻辑结构的分类：
    - 无结构文件：由**二进制或字符流**组成，无明显逻辑结构
    - 有结构文件：由**记录**组成，又称“记录式文件”，每条记录由若干**数据项/字段**组成。分为**定长**记录、**可变长**记录
      - **顺序**文件
      - **索引**文件
      - **索引**顺序
- <u>顺序文件</u>

  - **逻辑结构**定义：
    - 文件中的**记录**在逻辑上相邻，**顺序排列**
    - **串**结构：记录之间的顺序与关键字有关

      > 通常按照**存入的时间**决定记录的顺序
      >
    - **顺序**结构：记录之间的顺序与关键字无关
  - **物理存储**方式：
    - **链式**存储：**无法实现随机存取**，只能从第一个记录依次查找
    - **顺序**存储
      - **可变长**记录的顺序存储：**无法实现随机存取**，只能从第一个记录依次查找
      - **定长**记录的顺序存储：**可以实现随机存取**；串结构无法根据关键字快速索引；顺序结构可以根据关键字**快速索引**
  - 特点：
    - “顺序文件”一般指**物理上也顺序存储**的顺序文件
    - 缺点：增删记录较麻烦

      > 如果是串结构不保证顺序，则增加会相对简单
      >
- <u>索引文件</u>

  - **逻辑结构**定义：
    - 文件记录通过**索引表**组织起来，每个记录对应一个表项
    - 索引表：一种**定长记录的顺序文件**，可以随机存取，按关键字排序还可以**快速索引**；表项中包括**索引号**（key）、**记录长度**、**记录指针**等信息，可以根据索引号快速查询表项
  - **物理存储**方式：
    - 由索引表项的**指针**指向**逻辑文件记录**，文件记录可以在物理上**离散**存放
  - 特点：
    - 主要用于对**信息处理的及时性**要求比较高的场合
    - 可以用不同数据项为索引号（key）建立**多张索引表**
    - 方便**增删**，实现定长和可变长记录的**随机存取**
    - 缺点：索引表可能占用较大空间
- <u>索引顺序文件</u>

  - **逻辑**结构定义：
    - 文件记录**分组**后通过**索引表**组织起来，每个记录对应一个表项组
    - 索引表不必按关键字排序，顺序插入即可
  - **物理**存储方式：
    - 由索引表项的**指针**指向**逻辑文件记录组**，每组文件记录可以在物理上**离散**存放
    - 每组内文件记录**顺序**存放
  - 特点：
    - 检索时先**顺序查索引表**找到分组，再**顺序查找分组**内记录
    - 记录过多时可以建立多级索引表

---

#### *文件的物理结构：*

- <u>文件物理结构概述</u>

  - 文件物理结构的含义：在**操作系统**看来文件的数据是如何存放在**外存**的，是操作系统对**非空闲磁盘块**的管理方式，也是**文件分配方式**
  - 文件物理结构的分类
    - 连续分配
    - 链接分配
      - 隐式链接
      - 显式链接
    - 索引分配
- <u>文件块与磁盘块</u>

  - 磁盘块：**磁盘**中的所有存储单元以“块”为单位，称之为磁盘块
    - 磁盘块的大小与**页面**的大小相同
    - 内存与磁盘间的**数据交换**也是以“块”为单位
  - 文件块：文件的**逻辑地址空间**以“块”为单位，称之为文件块
    - 文件的逻辑地址可以表示为：`(逻辑块号, 块内地址)`
    - 操作系统**以块为单位**为文件**分配**存储空间，负责实现文件逻辑地址到物理地址的映射

      > “映射”本质是**逻辑块号**到**物理块号**的映射
      >
- <u>连续分配</u>

  - 存储方式：每个文件在磁盘上占有**一组连续的块**
  - 访问方式
    - 目录项：记录**起始块号**与**文件长度**
    - 通过`物理块号=起始块号+逻辑块号`计算，支持顺序访问与随机访问

      > 当然还需要检查逻辑块号是否合法：`逻辑块号<长度`
      >
  - 优缺点
    - 优点：**顺序存取**速度最快；支持**随机访问**
    - 缺点：产生**碎片**，外存利用率低；不利于文件**拓展**
- <u>链接分配-隐式链接</u>

  - 存储方式：离散分配，每个磁盘块都有指向下一个磁盘块的指针

    > 这些**指针对用户透明**
    >
  - 访问方式

    - 目录项：记录**起始**块号与**结束**块号
    - 从**起始块号**开始，将磁盘块**读入内存**，进而通过指针找到下一块并读入内存，直到结束

      > 读入i号逻辑块需要i+1次磁盘I/O（从0号块开始）
      >
  - 优缺点

    - 优点：不产生碎片，外存利用率高；方便文件拓展
    - 缺点：只支持**顺序访问，**不能随机访问
- <u>链接分配-显式链接</u>

  - 存储方式：离散分配，通过文件分配表(FAT)记录各**磁盘块**指向下一块的**指针/块号**
    - 一个**磁盘**仅设置一张**FAT**，开机时FAT读入**内存**并**常驻**
    - FAT表项：物理块号+下一块指针/块号

      > FAT各表项物理上连续存储且表项长度相等，所以物理块号其实可以隐含
      >
  - 访问方式：
    - 目录项：记录**起始块号**
    - 从**起始块号**开始，查**FAT**得到下一磁盘块指针/块号，直到找到需要的块号或下一块号为-1
  - 优缺点：
    - 优点：支持顺序访问，也支持**随机访问**，相比于隐式连接访问速度更块；不会产生碎片；方便拓展

      > 注意，随机访问指的是**访问第i块不需要依次访问前i-1块**，只需要查询**内存**中的FAT即可
      >
    - 缺点：FAT需要占用一定空间
- <u>索引分配</u>

  - 存储方式：为每个文件建立**索引表**

    - **索引表**记录文件各**逻辑块**对应的**物理块**

      - 索引表存放的磁盘块称为**索引块**
      - 文件数据存放的磁盘块称为**数据块**

        > 若文件过大，可以采用链接方案、多层索引、混合索引；
        >
        > 链接方案就是一级索引，索引表长度超过一个磁盘块大小则不得不链接存储
        >
        > 多层索引、混合索引的索引表长度不会超过一个磁盘块
        >
    - 多层索引：多级索引表

      > 会涉及到文件最大长度计算、访存次数计算的问题
      >
    - 混合索引：顶级索引表中部分表项是**直接地址索引**，部分表项是**一级间接**索引、**二级间接**索引等

      > 会涉及到文件最大长度计算、访存次数计算的问题
      >
  - 访问方式：

    - 链接方案的目录项：记录**(顶级)索引块块号**
    - 通过FCB找到各级索引表**读入内存**，查索引表得出逻辑块在外存中的磁盘块号
  - 优缺点：

    - 优点：支持随机访问，方便拓展；混合索引可以兼容大文件与小文件
    - 缺点：索引表需要占用存储空间；对于大文件，链接方案可能需要多次读取索引块；对于小文件，多层索引依然需要读入各级索引表

### 4.3 文件的存取与操作

#### *文件存储空间管理：*

- <u>存储空间划分与初始化</u>

  - 存储空间划分：将**物理磁盘**划分成一个个**文件卷**

    - 文件卷也叫逻辑卷、逻辑盘

    > 有的文件系统也可以将多个物理磁盘组成一个文件卷
    >
  - 存储空间初始化：将各个**文件卷**划分为**目录区和文件区**

    - 目录区：存放文件目录信息（**FCB、索引结点**）、磁盘存储空间**管理信息**等

      > 管理信息包括空闲表、位示图、超级块等
      >
    - 文件区：存放**文件数据**
- <u>存储空间管理方法</u>

  - 空闲表法

    - 记录与组织空闲磁盘块：用空闲盘块表每个空闲盘块区的**起始盘块号和盘块数**
      - 表项：起始盘块号、盘块数
    - 分配磁盘块：使用**动态分区分配算法**，为文件分配**连续**的存储空间，并**修改表项**
    - 回收磁盘块：回收并根据前后空闲分区情况**修改表项**
    - 适用情况：连续分配
  - 空闲链表法-空闲盘块链

    - **记录与组织**空闲磁盘块：以**盘块**为单位组成链表
      - 空闲盘块中存储下一个空闲盘块的指针
      - 操作系统保存着**链头、链尾指针**
    - **分配**磁盘块：从**链头**开始摘下若干个盘块分配，并修改**链头指针**
    - **回收**磁盘块：将回收的盘块挂到**链尾**，并修改**链尾指针**
    - 适用情况：离散分配。为文件分配多个磁盘块时效率较低，要重复多次操作
  - 空闲链表法-空闲盘区链

    - **记录与组织**空闲磁盘块：以**盘区**为单位组成链表
      - 盘区由连续的空闲盘块组成
      - 盘区的第一个盘块记录长度和指针
      - 操作系统保存着**链头、链尾指针**
    - **分配**磁盘块：使用**动态分区分配算法**，从**链头**检索合适的空闲盘区。若没有合适的盘区，可以分配不同盘区的盘块，并注意修改**链指针和盘区大小**
    - **回收**磁盘块：若回收区刚好与某一空闲区**相邻**，则**合并**；若**无相邻**，则将回收区作为单独的新空闲区挂到**链尾**。注意修改**链指针和盘区大小**
    - 适用情况：离散与连续分配均可。为文件分配多个磁盘块时效率更高
  - 位示图法

    - **记录与组织**磁盘块：

      - 用连续的“字”表示。一个“字”作为一**行**，“字”中的每个二进制位（一**列**）对应一个盘块，构成**位示图**

        > 例如“0”代表空闲、“1”代表分配
        >
      - 用`(字号, 位号)`对应**盘块号**，结合**字长**可以得出两者之间的数学关系
    - **分配**磁盘块：**顺序扫描**位示图，找到若干个**空闲块**的`(字号, 位号)`，算出**盘块号**，分配，并**修改相应位**
    - **回收**磁盘块：根据回收的**盘块号**计算`(字号, 位号)`，**修改相应位**
    - 适用情况：离散与连续分配均可
  - 成组链接法

    - **记录与组织**空闲磁盘块：

      - 空闲盘块以组为单位，可以不连续
      - 每组盘块的**第一块**要记录下一组的空闲盘块数和各空闲盘块号（指针），其他盘块就是不记录信息的空闲块
        - “第一个”这样的块就是**超级块**
        - “最后一个”这样的块会将**第一个空闲盘块号设为-1**，代表没有再下一组了
    - **分配**磁盘块：检查**超级块指向的分组**块数是否足够，足够则分配并修改信息，不足则先分配分组内所有块，并将**分组第一块信息**复制到**超级块**中，再从**下一组**中分配

      > 超级块就像一个`dummyHead`
      >
    - **回收**磁盘块：检查**超级块指向的分组**是否足够容纳，足够则插入该分组，不足则把回收的作为**新分组**，复制**超级块**内容至**新分组第一盘块**，并让超级块中记录新分组信息，直到回收所有块

      > 有点类似头插法
      >
    - 适用：离散与连续分配均可

---

#### *文件基本操作：*

- <u>创建文件</u>

  - 参数：
    - 所需外存**空间大小**
    - 存放**路径**
    - 文件**名**
  - 系统调用`create`
    - 分配**外存空间**
    - 创建**目录项**
- <u>删除文件</u>

  - 参数：
    - 存放**路径**
    - 文件**名**
  - 系统调用`delete`：
    1. 找到目录项
    2. 回收**外存空间**
    3. 删除目录项
- <u>打开文件</u>

  - 参数：

    - 存放路径
    - 文件名
    - 对文件的操作类型
  - 系统调用`open`：

    - 目录项：找到**目录项**并复制进**内存**的打开文件表中，检查操作权限

      > 只复制**目录项**而不复制**文件数据**
      >
    - 打开文件表：

      - **系统打开文件表**中的打开计数器加1
      - 返回**用户打开文件表**的索引号，用户使用该编号指明要操作的文件

        > 文件描述符
        >
  - 打开文件表：

    - 系统的打开文件表
      - **打开计数器**记录此时有多少进程打开了此文件
      - 方便系统实现某些文件管理功能
    - 用户进程的打开文件表
      - **读写指针**记录进程对文件读/写操作进行到的位置
      - **访问权限**记录用户进程对文件的访问权限
- <u>关闭文件</u>

  - 参数：打开文件表的编号
  - 系统调用`close`
    - 删除用户进程**打开文件表项**
    - 回收该文件的进程**内存空间**等资源
    - 系统打开文件表打开计数器减1，如果减到0则删除表项
- <u>读文件</u>

  - 参数：

    - 打开文件表的**编号**
    - 读入的**数据量**
    - 读入到的**内存位置**
  - 系统调用`read`：

    - 根据读写指针指向的**外存**空间**读入**指定数据，存放至指定**内存**位置

      > 从外存读入内存。如果所读数据文件不在内存，会产生中断（**缺页中断**），阻塞进程，直到所需数据从外存调入内存。
      >
- <u>写文件</u>

  - 参数：

    - 打开文件表的**编号**
    - 写回的**数据量**
    - 被写回数据的**内存位置**
  - 系统调用`write`

    - 从**内存**指定位置**读出**指定数据，写回读写指针指向的**外存**空间

      > 从内存写回外存
      >

---

#### *文件共享与保护：*

- <u>文件共享</u>

  - **硬链接**/基于**索引结点**的共享方式

    - 不同**目录项**指向同一个**索引结点**，索引结点上设置**链接计数变量**
    - 用户删除文件时只删除目录项，并将链接计数变量减1，若减为0则删除索引结点和文件数据

      > 否则会导致指针悬空
      >
  - **软链接**/基于**符号链**的共享方式

    - 创建**Link类型文件**来记录文件存放路径

      > 例如Windows的快捷方式
      >
    - 源文件被删除会导致Link文件失效
    - 可能涉及到查询多级目录，多次I/O操作
- <u>文件保护</u>

  - 口令保护

    - 保护方式：为文件**设置口令**，用户访问时需要**提供口令**，系统验证是否正确
    - 评价：开销小，但口令一般存放在**FCB或索引结点**中，不太安全
  - 加密保护

    - 保护方式：用密码**加密**文件，用户访问时需要**提供密码**才能**解密**文件
    - 评价：安全性高，但加密解密需要一定开销
  - 访问控制

    - 保护方式：在**FCB或索引结点**中增加**访问控制列表**(Access-Control List, ACL)，记录各（组）用户对文件的**访问权限**

      > 文件本身也有访问相关的属性，所以对一个文件的访问，常由**用户访问权限和文件属性**共同限制
      >
    - 访问类型：

      - 读、写、删除
      - 执行：将文件装入内存并执行
      - 追加：在文件结尾添加新信息
      - 列表清单：列出**文件名和属性**信息
    - 评价：灵活，可实现复杂文件保护功能
  - 存取控制矩阵

    - 行为所有文件，列为所有用户，表项为相关权限
    - 优点：权限规定细致
    - 缺点：过于繁琐，占用较多存储空间

### 4.4 磁盘的结构与管理

#### *磁盘的结构与读写：*

- <u>磁盘结构</u>

  - 磁盘与**盘面**：磁盘由表面涂有磁性物质的圆形盘片组成，用于记录二进制数据
  - 磁道与**柱面**：

    - 盘面被划分成若干圆环，每个圆环就是一条**磁道**
    - 若干**盘面垂直放置**，同一铅锤线上（相对位置相同）的磁道构成一个**柱面**
  - **扇区**与磁盘块

    - **一个磁道**被划分成若干扇区，一个扇区也是一个磁盘块
    - 各扇区（包括不同磁道上的）存储的**数据量相同**

      > 最内侧磁道扇区面积最小，数据**密度**最大
      >
- <u>磁盘读写</u>

  - 磁盘的物理地址：`(柱面号, 盘面号, 扇区号)`
  - 磁盘的读写过程
    1. 根据**柱面**号移动磁臂，将**磁头**移动到指定柱面
    2. 激活**盘面**对应磁头
    3. 磁盘旋转，指定**扇区**从磁头下划过时，完成读写
  - 地址结构的设计
    - 若采用`(盘面号, 柱面号, 扇区号)`，读取连续物理地址时，很可能经常**启动磁头臂，切换柱面**，效率较低
    - 若采用`(柱面号, 盘面号, 扇区号)`，读取连续物理地址时，很可能经常切换**盘面**，但这**不需要移动磁头臂**，这需要激活相邻盘面的**磁头**
- <u>磁盘分类</u>

  - 按磁头是否可移动
    - 移动头/活动头磁盘：每个盘面只有一个磁头，磁臂可以来回伸缩带动磁头定位磁道
    - 固定头磁盘：每个磁道均有一个磁头
  - 按磁盘片是否可更换
    - 固定盘磁盘
    - 可换盘磁盘

---

#### *磁盘调度算法：*

- <u>时间衡量指标</u>

  - 寻找时间/寻道时间$T_s$：在读/写数据前，启动磁臂，**移动磁头到指定磁道**所花的时间

    $T_s=s+m\times n$

    - 启动磁头臂耗时：s
    - 移动磁盘耗时：匀速移动，每跨域一个磁道耗时m，共需跨越n条磁道

    > 现代硬盘s约为2ms，m*n约为0.2ms；
    >
    > 受磁盘调度算法影响，操作系统可以通过磁盘调度算法控制
    >
  - 延迟时间$T_R$：**旋转磁盘**，使磁头定位到目标扇区所需时间

    $T_R=\frac12\times\frac1r=\frac1{2r}$

    - r：磁盘转速

    > 硬盘典型转速为5400转/分或7200转/分；
    >
  - 传输时间$T_t$：对磁盘**读写数据**经历的时间

    $T_t=\frac1r\times\frac bN=\frac b{rN}$

    - b：此次读写的字节数
    - N：每个**磁道**上的字节数

    > 转速r是**硬件固有属性**，操作系统不可控
    >
  - 减少延迟时间的方法

    - 交替编号：编号相邻的扇区在**物理上不相邻**
      - 原理：访问完一个扇区需要**处理一段时间**才能访问下一扇区，而磁盘是**不停旋转**的
    - 错位命名：相邻盘面扇区**编号错位**
      - 原理：与“交替编号”原理相同。可以**减少延迟时间**
- <u>先来先服务(FCFS)</u>

  - 思想：按访问请求到达的**先后顺序**进行处理
  - 优点：
    - 公平
    - 若磁道访问比较集中，性能尚可
  - 缺点：
    - 若磁道访问分散，则性能差，寻道时间长
- <u>最短寻找时间优先(SSTF)</u>

  - 思想：每次都优先响应**距离磁头最近**的磁道访问请求

    > 贪心算法的思想
    >
  - 优点：性能好，**平均寻道时间较短**
  - 缺点：

    - 可能导致**饥饿**
    - 磁头可能在小区域来回移动
- <u>扫描算法/电梯算法(SCAN)</u>

  - 思想：只有**磁头移动到最边缘**才能改变磁头移动方向，移动途中响应请求

    > 为了防止SSTF中磁头在小区域来回移动的情况
    >
  - 优点：

    - 性能好，**平均寻道时间较短**
    - 不会产生**饥饿现象**
  - 缺点：

    - 只有到达最边缘才能改变磁头方向
    - 对各位置磁道**响应频率不均匀**
- <u>循环扫描算法(C-SCAN)</u>

  - 思想：磁头移动到最边缘时**立即返回另一边**，返回途中不响应请求，移动途中响应请求
  - 优点：基于SCAN，比SCAN响应各位置磁道更平均
  - 缺点：
    - 只有到达最边缘才能改变磁头方向，且返回时必须返回到另一边缘
    - 平均寻道时间比SCAN更长
- <u>LOOK算法</u>

  - 思想：基于SCAN算法，只要在磁头移动方向上**不再有请求**，就立即改变磁头方向

    > 若题目中无特别说明，SCAN算法指的就是LOOK算法
    >
  - 优点：基于SCAN算法，寻道时间进一步缩短
- <u>C-LOOK算法</u>

  - 思想：基于C-SCAN算法，只要在磁头移动方向上**不再有请求**，就立即改变磁头方向，且只需要**返回到有磁道访问请求**处

    > 若题目中无特别说明，C-SCAN算法指的就是C-LOOK算法
    >
  - 优点：基于C-SCAN算法，寻道时间进一步缩短

---

#### *磁盘的管理：*

- <u>磁盘初始化</u>

  1. 低级格式化/物理格式化：将磁盘和各个磁道划分为**扇区**

     - 一个扇区可分为**头、数据区域、尾**三个部分
     - 头和尾可存放**扇区管理信息**

       > 扇区校验码等
       >
  2. 磁盘分区：每个分区由若干柱面组成

     > 这是为了**操作系统**能将自己的数据结构记录在磁盘上
     >
  3. 逻辑格式化：建立**文件系统**

     - 建立根目录文件
     - 建立用于存储空间管理的数据结构

       > 位示图、空闲分区表等
       >
- <u>引导块的管理</u>

  - **初始化程序/自举程序**：完成计算机启动时的初始化工作

    - 若将整个初始化程序存放于ROM中，则无法修改，灵活性差
  - **引导块/启动块/启动分区**：位于磁盘的固定位置，存放完整的初始化程序

    - 拥有启动分区的磁盘称为**启动磁盘**或**系统磁盘**

      > 例如Windows中的C盘
      >
  - 自举装入程序：**ROM**中存放的较小的装入程序，计算机启动时运行，从而找到引导块，读入完整的**自举程序**到**内存**，完成初始化
- <u>坏块的管理</u>

  - 坏块的概念：无法正常使用的**扇区**

    - 属于**硬件故障**，操作系统无法修复
    - 应当将**坏块标记**，以免错误使用
  - 坏块的标记：

    - **对操作系统不透明**的方法：**逻辑格式化**时将坏块标记出来

      > 例如：在FAT上标明
      >
      > 适用于简单的磁盘
      >
    - **对操作系统透明**的方法：**物理格式化**时，**磁盘控制器**就开始维护一个**坏块链**，并管理**备用扇区**，替换坏块

      > 磁盘控制器是是磁盘内部的硬件部件；
      >
      > 这种方式也叫**扇区备用方案**，适用于复杂磁盘
      >

## 5 设备管理

### 5.1 I/O设备概述

#### *I/O设备的概念：*

- 将**数据输入/输出**计算机的外部设备

  > UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作
  >
- 属于计算机中的硬件部件

---

#### *I/O设备的分类：*

- <u>按**使用特性**分类</u>

  - **人机交互**类外部设备

    > 如键盘、鼠标、打印机等；
    >
    > 数据传输速度慢
    >
  - **存储**设备

    > 如移动硬盘、光盘等；
    >
    > 数据传输速度快
    >
  - **网络通信**设备

    > 如调制解调器等；
    >
    > 数据传输速度介于二者之间
    >
- <u>按**传输速率**分类</u>

  - 低速设备

    > 如鼠标、键盘等；
    >
    > 传输速率为每秒几个到几百个字节
    >
  - 中速设备

    > 如激光打印机等；
    >
    > 传输速率为每秒数千到上万个字节
    >
  - 高速设备

    > 如磁盘等；
    >
    > 传输速率为每秒数千到千兆个字节
    >
- <u>按**信息交换**的单位分类</u>

  - 块设备

    - 传输速率较高
    - 可寻址：可以随机读/写任一块

    > 如磁盘等；
    >
    > 数据传输的**基本单位是“块”**
    >
  - 字符设备

    - 传输速率较低
    - 不可寻址
    - 在输入/输出时常采用中断驱动方式

    > 如鼠标、键盘等；
    >
    > 数据传输的**基本单位是字符或字节**
    >

### 5.2 I/O控制

#### *I/O控制器：*

- <u>I/O设备的构成</u>

  - 机械部件：用于**执行具体I/O操作**的部分

    > 例如鼠标和键盘的按钮、显示器的LED屏、移动硬盘的磁臂、移动硬盘的磁盘盘面等
    >
  - **电子部件/IO控制器/设备控制器**：一块插入主板扩充槽的印刷电路板，操作系统通过电子部件间接控制机械部件
- <u>I/O控制器主要功能(对外)</u>

  - **控制**：接受和识别CPU发出的命令
  - **状态**：向CPU报告设备的状态
  - **数据**：数据交换
  - **地址**：地址识别

    - I/O控制器为上述各寄存器设置特定“地址”，通过CPU提供的地址判断要读/写的寄存器
- <u>I/O控制器的内部组成与功能</u>

  - CPU与控制器的接口

    - 功能：在CPU与控制器之间传输信号
    - 组成部分：

      - **控制寄存器**：存放命令和参数

        > 如CPU发来的read/write命令
        >
      - **状态寄存器**：记录I/O设备当前状态

        > 如1表示空闲，0表示忙碌
        >
      - **数据寄存器**：在输入/输出时暂存数据，CPU通过数据线取出和放入数据
  - I/O逻辑：

    - 功能：识别CPU发出的命令，并向设备发出命令，实现**对设备的控制**
    - 组成部分
      - **地址线**：CPU通过地址线指明要操作的**设备**
      - **控制线**：CPU通过控制线发出**命令**
  - 控制器与设备的接口

    - 功能：在控制器与设备之间传输信号
    - 组成部件

      - **数据**部分：传送要输入/输出的数据
      - **状态**部分：设备向控制器反馈状态

        > 忙碌或空闲
        >
      - **控制**部分：控制器向设备发出控制信息
- <u>两种寄存器编址方式</u>

  > 一个I/O控制器可以控制多个设备。数据寄存器、控制寄存器、状态寄存器可以有多个，这些寄存器都要有相应的**地址**
  >

  - **内存映像I/O**
    - 编址方式：控制器中的寄存器与内存**统一编址**
    - 优点：可以采用**对内存操作的指令**来对控制器进行操作
    - 缺点：占用内存地址空间
  - **寄存器独立编址**
    - 编址方式：控制器中的寄存器独立编址
    - 优点：不占用内存地址空间
    - 缺点：需要设置**专门的指令**来操作控制器

---

#### *I/O控制方式：*

> 总体来说，I/O控制方式的发展过程就是要尽量**减少CPU对I/O过程的干预**，将CPU从I/O中解脱出来，以便高效处理数据任务

- <u>程序直接控制方式</u>

  - 读写流程：轮询

    > 以读操作为例具体讲解。其他方式的读写流程可以类比
    >

    1. CPU向控制器发出读指令，设备启动，**状态寄存器**设为1
    2. CPU轮询检查控制器状态，直到状态寄存器变为0
    3. 输入设备准备数据后将数据传给控制器，并报告状态

       > 这里的状态可能是正常，也可能是**错误条件**
       >
    4. 控制器接收数据存入**数据寄存器**中，修改状态寄存器为0
    5. CPU发现设备就绪，从数据寄存器中读取数据至**寄存器**，再存入**内存**
    6. 如果还需要读取数据，CPU可以继续发出读指令
  - CPU干预频率：极高

    - 一次I/O开始前、完成后需要CPU介入
    - 一次I/O过程中CPU需要轮询
  - 数据传输

    - 单位：每次读/写**一个字**
    - 流向：
      - 读：I/O设备$\rarr$CPU寄存器$\rarr$内存
      - 写：内存$\rarr$CPU寄存器$\rarr$I/O设备
  - 评价

    - 优点：**实现简单**，在读/写指令后，加上实现轮询逻辑的一系列指令即可

      > 因此得名“程序直接控制方式”
      >
    - 缺点：CPU和I/O设备**串行**工作，CPU需要轮询“忙等”，**资源利用率低**
- <u>中断驱动方式</u>

  - 读写流程：中断

    1. CPU发出I/O命令，**阻塞**等待I/O的进程，切换到其他进程执行其他命令
    2. I/O完成后，**控制器**向CPU发出**中断信号**
    3. CPU检测到中断信号，保存进程现场，执行**中断处理程序**

       > CPU会在每条指令末尾检测中断信号；
       >
       > 中断处理过程需要保存、恢复进程运行环境，有一定开销，可能降低系统性能
       >
    4. CPU、I/O控制器、主存交换数据
    5. I/O结束后，CPU恢复等待I/O的进程
  - CPU干预频率

    - 一次I/O开始前、完成后需要CPU介入
    - 一次I/O过程中CPU可以切换到其他进程
  - 数据传输

    - 单位：每次读/写**一个字**
    - 流向：
      - 读：I/O设备$\rarr$CPU寄存器$\rarr$内存
      - 写：内存$\rarr$CPU寄存器$\rarr$I/O设备
  - 评价

    - 优点：I/O过程中CPU和I/O设备可**并行工作**，**资源利用率提升**
    - 缺点：频繁中断处理会消耗CPU较多时间
- <u>DMA方式</u>

  - DMA(Direct Memory Access)控制器：一种特殊的I/O控制器

    - DR(Data Register)：暂存**设备与内存**之间传递的数据
    - MAR(Memory Address Register)：指明数据 **在内存/存放到内存** 中的位置
    - DC(Data Counter)：剩余要读/写的字节数
    - CR(Command Register)：存放CPU发来的**I/O命令**或**设备状态**
  - 读写流程：

    1. CPU向DMA发出命令，阻塞I/O进程，切换到其他进程
       - 操作类型
       - 数据量
       - 内存地址
       - 外部设备地址
    2. DMA准备好**一块数据**后，向CPU发出中断信号
  - CPU干预频率

    - 一次I/O开始前、完成后需要CPU介入
    - 一次I/O过程中CPU可以切换到其他进程
  - 数据传输

    - 单位：每次读/写**一块或多块连续数据**

      > 如果要操作多块数据，则必须是**连续的多块数据**，离散的多块依然需要**中断**
      >
    - 流向：

      - 读：I/O设备器$\rarr$内存
      - 写：内存器$\rarr$I/O设备
  - 评价

    - 优点：数据传输**以“块”为单位**，CPU介入频率降低；内存与设备之间数据传输不需要经过CPU，提升数据传输率，提高CPU与I/O设备并行性。
    - 缺点：CPU每发出一条I/O指令，只可以读写一个或多个连续块。如果要读写多个离散块，或要写入离散内存区域，CPU需要发出多条I/O指令，经历多次**中断**。
- <u>通道控制方式</u>

  - 通道：一种硬件，可以识别CPU指令，并执行一系列**通道指令**，控制I/O控制器操作设备

    > 通道可以执行的指令很单一，且通道程序存放于内存中，与CPU共享内存；
    >
    > 一个系统中可以有多个通道，一个通道可以控制多个I/O控制器，一个I/O控制器也可以控制多个I/O设备
    >
  - 读写流程：

    1. CPU向通道发出I/O指令，指明**通道程序**在内存中的位置，指明**要操作的设备**，阻塞I/O进程，切换到其他进程
    2. 通道执行**通道程序**
       - 操作类型
       - 数据量
       - 内存地址
       - 外部设备地址
    3. 通道执行完任务后，向CPU发出**中断**信号，CPU处理中断
  - CPU干预频率：极低

    - 一次通道程序执行开始前、完成后需要CPU介入
    - 一次通道程序执行过程中CPU可以切换到其他进程
  - 数据传输

    - 单位：每次读/写**一组数据块**
    - 流向：
      - 读：I/O设备器$\rarr$内存
      - 写：内存器$\rarr$I/O设备
  - 评价

    - 优点：CPU、通道、I/O设备可并行工作，资源利用率很高

      > 通道和中断技术结合能实现CPU与I/O的**并行**工作。通道可以独立于CPU运行，中断可以避免CPU轮询
      >
    - 缺点：需要专门的通道硬件支持

### 5.3 I/O系统

#### *I/O软件层次结构：*

- <u>用户层软件</u>

  - 对上层的服务：实现与用户交互的接口，提供方便的**库函数**
  - 对下层的调用：将用户请求翻译成格式化的I/O请求，通过**系统调用**请求操作系统内核服务
- <u>设备独立性软件/系统调用处理层</u>

  - 对上层的服务：提供统一的系统调用接口，进行**I/O调度**
  - 对下层的封装：

    - **设备保护**：将设备看作特殊的文件，类似**文件保护**
    - **差错处理**：对设备的错误进行处理
    - **设备分配与回收**：对设备这种**临界资源**进行分配回收
    - **数据缓冲区管理**：通过缓冲技术屏蔽设备之间数据交换单位和传输速度的差异
    - **设备映射**：通过**逻辑设备表（LUT）**，建立**逻辑设备名与物理设备名**的映射关系；根据设备类型调用相应的驱动程序

      > 逻辑设备表（LUT），也可称为**设备映射表（DMT）**
      >
      > LUT的字段：
      >
      > - 逻辑设备名：以**文件路径**的形式体现
      > - 物理设备名
      > - **驱动程序入口地址**
      >
      > LUT管理方式：
      >
      > - 各个操作系统只有一张
      > - 每个用户均有一张，存放于用户管理进程的PCB中
      >
- <u>设备驱动程序</u>

  > 直接与硬件交互，进行与中断无关的操作
  >

  - 对上层的服务：解释上层命令，转化为特定的**设备操作**
  - 对下层的调用：控制硬件，执行符合硬件特性的驱动；设置设备寄存器，检查设备状态等

    > 驱动程序一般会以一个**独立进程**的方式存在
    >
- <u>中断处理程序</u>

  > 直接与硬件交互，进行与中断有关的操作
  >

  - 对上层的服务：提供**对中断的处理**
  - 对下层的调用：接收控制器的**中断信号**，处理I/O数据
- <u>硬件层</u>：参考“**I/O控制**”小节

---

#### *I/O核心子系统功能：*

```
I/O核心子系统功能
	- I/O调度
	- 设备保护
	- 假脱机技术
	- 设备的分配与回收
	- 缓冲区管理
```

> I/O核心子系统包括：
>
> - 设备独立性软件
> - 设备驱动程序
> - 中断处理程序

- <u>I/O调度</u>

  - 用某种**算法**确定一个**处理I/O请求的顺序**

    > 例如：先来先服务、优先级算法、短作业优先算法等
    >
- <u>设备保护</u>

  - 操作系统提供**文件保护**功能，管理**用户访问权限**
  - 将**设备**看作特殊的**文件**，有对应的FCB
- <u>假脱机技术/SPOOLing技术</u>

  - **脱机技术**

    - 工作方式：在**外围控制机**控制下，**设备**与**磁带**数据交换，**主机**与**磁带**数据交换

      > 这个过程不需要主机/CPU的控制，所以叫“脱机”
      >
    - 作用：缓解设备与CPU的速度矛盾，实现**预输入、缓输出**
  - **假脱机技术**：用**软件**的方式模拟脱机技术

    - **输入井与输出井**：在**磁盘**中开辟出的两块存储区域，模拟**脱机技术中的磁带**，收容**I/O设备输入与进程输出**的数据
    - **输入进程与输出进程**：模拟脱机输入输出时的**外围控制机**

      > 所以，要实现SPOOLing技术，必须要有**多道程序技术**的支持
      >
    - **输入缓冲区与输出缓冲区**：**内存**中的缓冲区，输出输出时的“中转站”，在**输入输出设备**与**输入输出井**之间缓冲
  - **作用**：用SPOOLing技术可以将独占式设备改造成共享设备

    > 举例：共享打印机
    >
    > - 相关数据结构
    >   - **输出井中的空闲缓冲区**：存放用户要打印的数据
    >   - **假脱机文件队列**：存放打印请求表（说明用户的打印数据**存放位置**等信息）
    > - 工作流程
    >   1. 用户进程提出打印请求
    >   2. 系统应答用户请求，为该进程分配输出井中的**空闲缓冲区**，并建立**打印请求表**，挂到假脱机文件队列上
    >   3. 打印机空闲时，取出一张打印请求表，将数据从输出井送往**输出缓冲区**，再**输出**到打印机，处理打印任务
    > - 共享性的实现
    >   - 用输出井为每个打印进程分配存储区，相当于分配逻辑设备，实现共享性
    >
- <u>设备的分配与回收</u>

  - 设备**固有属性**/设备的独占式性与共享性

    - 独占式设备：只允许各个进程**串行**使用的设备
    - 共享设备：允许多个进程**并发**使用的设备

      > 往往是宏观上并行，微观上交替
      >
    - 虚拟设备：采用**SPOOLing技术**将独占设备改造成虚拟的共享设备，允许**多进程共享**
  - 设备**分配算法**：与I/O调度算法类似，有先来先服务、优先级、短作业优先等等
  - 设备**安全性**：

    - **安全分配**方式：为进程分配一个设备后就将其阻塞，直到I/O完成再唤醒

      > 一段时间内每个进程只能使用一个设备，破坏了“请求和保持”条件，但对一个进程来说，CPU和I/O设备只能串行工作
      >
    - **不安全分配**方式：为进程分配一个设备后，进程可继续执行并发出新的I/O请求，只有某个I/O请求得不到满足时才将进程阻塞

      > 一个进程可同时使用多个设备，可以并发处理计算任务和I/O任务，但有可能发生死锁，需要死锁避免、死锁的检测和解除
      >
  - 设备**静态分配与动态分配**

    - 静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源

      > 破坏“请求和保持”条件
      >
    - 动态分配：进程运行过程中动态申请设备资源
  - 设备分配管理中的**数据结构**

    - 通道控制表（CHCT）：每个通道均有一张，记录其信息

      - 通道**标识符**：各通道的唯一ID
      - 通道**状态**：忙碌、空闲、故障等
      - 与通道连接的控制器表首址：通过该指针可以找到所有COCT

        > 系统中可以有多个通道，一个通道可控制多个I/O控制器，一个I/O控制器又可控制多个设备
        >
      - 通道队列的指针：指向正在等待该通道的**进程队列**（由进程PCB组成）

        > 回顾：系统会根据阻塞原因不同，将进程PCB挂到不同的阻塞队列中。接下来的控制器队列和通道队列也同理
        >
    - **控制器控制表**（COCT）：每个I/O控制器均有一张，记录其信息

      - 控制器**标识符**：各I/O控制器的唯一ID
      - 控制器**状态**：忙碌、空闲、故障等
      - 指向**通道控制表**的指针
      - **控制器队列**的指针：指向正在等待该I/O控制器的**进程队列**（由进程PCB组成）
    - **设备控制表**（DCT）：每个设备均有一张，记录设备情况

      - 设备**类型**：打印机、扫描仪、键盘等
      - 设备**标识符**：即**物理设备名**，系统中每个设备的物理设备名唯一
      - 设备**状态**：忙碌、空闲、故障等
      - 指向**控制器控制表**的指针
      - 重复执行次数或时间：重复多次I/O操作或一段时间或I/O仍然不成功，则认为I/O失败
      - **设备队列**的指针：指向正在等待该设备的**进程队列**（由进程PCB组成）
    - 系统设备表（SDT）：记录系统中全部设备的情况，每个设备对应一个条目

      - 设备**类型**
      - 设备**标识符**
      - **DCT**
      - **驱动程序入口**
  - 设备**分配流程**及其改进

    1. 根据进程请求的**物理设备名**查找**SDT**

       > 使用**物理设备名**的缺点：
       >
       > - **底层细节**对用户不透明，编程不方便
       > - 若**更换**物理设备，则进程无法运行
       > - 若设备正在忙碌，进程必须**阻塞**，无法使用**同类型设备**
       >
       > 改进：
       >
       > - 用户只需提供逻辑设备名或**设备类型**
       > - 建立逻辑设备表（LUT），若在表中找到符合要求的设备可直接尝试分配
       >
    2. 根据**SDT**找到**DCT**，若设备**忙碌**则将进程PCB挂到**设备队列**，不忙碌则分配设备

       > 改进：
       >
       > - 查找SDT中**指定类型且空闲**的设备，找到则分配，都忙碌则阻塞
       > - 分配成功后在逻辑设备表中**新增表项**
       >
    3. 根据DCT找到COCT，若I/O控制器**忙碌**则将进程PCB挂到**控制器队列**，不忙碌则分配设备
    4. 根据COCT找到CHCT，若通道**忙碌**则将进程PCB挂到**通道队列**，不忙碌则分配设备
    5. 只有设备、控制器、通道均分配成功，这次设备分配才算成功，然后可以启动I/O设备进行数据传输
- <u>缓冲区管理</u>

  - 缓冲区概述

    - 概念：本节课中指的是**内存缓冲区**，是**设备独立性软件**负责管理好的缓冲区
    - 特性：向缓冲区**充入数据**与从缓冲区**取出数据**的操作必须串行
    - 作用：
      - 缓和CPU与I/O设备**速度不匹配**的矛盾
      - 提高CPU与I/O设备之间并行性
      - 减少CPU**中断频率**
      - 解决**数据粒度不匹配**问题
    - 工作框架：设备--(T)--缓冲区--(M)--工作区--(C)--处理
      - **块设备**：即慢速I/O设备
      - **缓冲区**：位于**内存**中，与块设备进行**数据输入/输出（T）**
      - **进程工作区**：位于**内存**中，与缓冲区进行**数据传送（M）**
      - **CPU**：对进程工作区的数据进行**处理（C）**
  - **单缓冲**

    - 策略：操作系统为本次请求读写的块设备在**主存**中分配**一个缓冲区**

      > 若无特殊说明，一个缓冲区大小就是**一块**
      >
    - 处理一块数据的平均耗时：Max(C, T)+M

      > 分析问题的初始状态：工作区满、缓冲区空
      >
    - 主机间通信时的应用：若两机配置单缓冲区，则同一时刻只能一方发送、一方接收
  - **双缓冲**

    - 策略：操作系统为本次请求读写的块设备在**主存**中分配**两个缓冲区**
    - 处理一块数据的平均耗时：Max(T, C+M)

      > 分析问题的初始状态：工作区空，一个缓冲区满、另一个缓冲区空
      >
    - 主机间通信时的应用：若两机配置双缓冲区，则可以同时发送与接收
  - **循环缓冲**：多个缓冲区链接成**循环队列**，in指针指向第一个空缓冲区，out指针指向第一个满缓冲区
  - **缓冲池**

    - 三个队列：
      - 空缓冲队列：存储**空缓冲区**
      - 输入队列：存储存放了**输入数据**的缓冲区
      - 输出队列：存储存放了**输出数据**的缓冲区
    - 四种工作缓冲区
      - 收容输入（hin）：**输入进程输入**时会从**空缓冲队列**中摘下缓冲区置于此，接收完输入后再挂到**输入队列**中
      - 提取输入（sin）：**计算进程取得输入**时会从**输入队列**中摘下缓冲区置于此，提取输入后再挂回**空缓冲队列**
      - 收容输出（hout）：**计算进程产生输出**时会从**空缓冲队列**中摘下缓冲区置于此，接收完输出后再挂到**输出队列**中
      - 提取输出（sout）：**输出进程输出**时会从**输出队列**中摘下缓冲区置于此，提取输出后再挂回**空缓冲队列**
