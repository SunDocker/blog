---
title: 编译原理
abbrlink: 118b8ca3
date: 2022-11-18 10:22:28
tags:
    - Computer
    - Compile Principle
category: Computer Theory
---
## 1 绪论

### 1.1 编译相关的概念

- 编译的概念

  - 编译就是将高级语言(**源语言**)翻译成汇编语言或机器语言(**目标语言**)的过程
- 三种程序

  - **翻译**程序(**Translator**)： 将某一种语言描述的程序(Source Program)翻译成等价的另一种语言描述的程序(Object Program)的程序

    - 翻译程序-**解释**程序(**Interpreter**)：一边解释一边执行的**翻译程序**

      > 类似生活中的“口译”
      >
    - 翻译程序-**编译**程序(**Compiler**)：将源程序完整地转换成机器语言程序或汇编语言程序，然后再处理、执行的**翻译程序**

### 1.2 编译系统的结构

- 编译系统的构成

  - **编译程序**
    - 预处理器
    - 编译器
    - 汇编器
    - 链接器/加载器
  - 运行系统
- 编译器的8个模块

  ```
                                          |
                                          |SourceProgram
                                          V
      ------------                ----------------                  ------------
      |          |<-------------->|LxicalAnalyzer|<---------------->|          |
      |          |                ----------------                  |          |
      |          |                        |                         |          |
      |          |                        |Tokens                   |          |
      |          |                        V                         |          |
      |          |                    --------                      |          |
      |          |<------------------>|Parser|<-------------------->|          |
      |          |                    --------                      |          |
      |          |                        |                         |          |
      |          |                        |GrammarticalUnit         |          |
      |          |                        V                         |          |
      |   Form   |   --------------------------------------------   |  Error   |
      |Management|<->|SemanticAnalyzer IntermediateCodeGenerator|<->|Management|
      |          |   --------------------------------------------   |          |  
      |          |                        |                         |          |
      |          |                        |IntermediateCode         |          |
      |          |                        V                         |          |
      |          |                 ---------------                  |          |
      |          |<--------------->|CodeOptimizer|<---------------->|          |
      |          |                 ---------------                  |          |
      |          |                        |                         |          |
      |          |                        |IntermediateCode         |          |
      |          |                        V                         |          |
      |          |              ---------------------               |          |
      |          |<------------>|ObjectCodeGenerator|<------------->|          |
      ------------              ---------------------               ------------
                                          |
                                          |ObjectCode
                                          V
  ```

  - 分析
    1. 词法分析（lexical analyzer/scanner）
    2. 语法分析（syntax analyzer/parser）
    3. 语义分析
  - 综合
    1. 中间代码生成
    2. 代码优化
    3. 目标代码生成
  - 辅助
    1. 表格管理/符号表管理
    2. 出错处理

### 1.3 词法分析概述

- 功能

  - 生成token：词法分析器扫描源程序字符串，识别**单词**，确定类型，生成单词(***token***)串
    - token：**(种别码, 属性值)**序对
  - 表格管理：登记标识符
  - 错误管理：查词法错误
- 输入与输出

  - 输入：源程序字符串
  - 输出：token序列

### 1.4 语法分析概述

- 功能

  - token：从**token序列**中，识别**语法成分/短语**，构造**语法分析树**，指导**翻译**过程

    - 用token组成各类**语法成分/短语**：表达式、因子、项、语句、子程序…

      > “组词成句”
      >
  - 错误管理：指出**语法错误**
- 输入与输出

  - 输入：token序列
  - 输出：语法分析树（包括**语法成分**）

### 1.5 语义分析概述

- 功能

  - 语法分析树：根据语法分析树，分析由语法分析器识别出来的**语法成分的语义**
    - 语义分析一般和语法分析同时进行，称为**语法制导翻译(syntax-directed translation)**
    - 高级语言程序中的语句大体分为两类，一类是**声明语句**，一类是**可执行语句**。对于声明语句来说，语义分析的主要任务是**收集标识符的属性信息**
  - 表格管理：收集**标识符**属性信息，完善**符号表**；进行子程序和变量的**静态绑定**
    - 属性信息：种别、类型、值、作用域、...
    - 子程序：代码的相对地址
    - 变量：数据的相对地址，大小
  - 错误管理：**语义检查**
    - 变量或过程**未经声明就使用**
    - 变量或过程名**重复声明**
    - **运算分量**类型不匹配
    - **操作符**与**操作数**之间的类型不匹配
- 输出与输出

  - 输入：语法分析树（包括**语法成分**）
  - 输出：语法分析树（包括**语法成分**）

### 1.6 中间代码生成及编译

- 功能：

  - 生成与机器无关、易于优化与转化的中间表示形式（常用**三地址码**），以此**实现语义**

    > 三地址码又有多种表示形式，其中**四元式**较为常用
    >
    > 中间代码的**优点**：
    >
    > - 方便通过中间表示形式进行**代码优化**
    > - 方便源程序的跨平台**移植**
    >
- 输入与输出

  - 输入：语法分析树（包括**语法成分**）
  - 输出：中间表示形式（常用**三地址码**）

### 1.7 代码优化

- 功能

  - 通过**等价**程序变换对中间代码进行优化，使程序更有效利用机器资源，节省**存储空间**，提高**运行速度**和效率
- 优化方式

  - 与机器无关的优化
    - 局部优化
      - 常数合并
      - 公共子表达式提取
    - 循环优化
      - 强度削减
      - 代码外提
    - 全局优化
  - 与机器有关的优化
    - 寄存器的利用
    - 体系结构
    - 存储策略
    - 任务划分

### 1.8 目标代码生成

- 功能：将**中间代码**转换成**目标机**上的机器指令代码或汇编代码

  > 目标代码的形式：
  >
  > - 具有**绝对地址**的机器指令
  > - 模块结构的机器指令（需要**链接程序**）
  > - 汇编语言
  >
- 输入与输出

  - 输入：中间表示形式（常用**三地址码**）
  - 输出：目标代码（一般为汇编语言）

### 1.8 表格管理

管理各种**符号**和**符号表**，辅助语法检查、语义检查，完成静态绑定，为编译的各个阶段提供信息

### 1.9 错误管理

进行各种错误的检查、报告、纠正，以及相应的**续编译处理**

### 1.10 编译程序的组织与生成

*编译程序设计的目标：*

- 程序本身：

  - 规模小、速度快、诊断能力强、可移植性好，可扩充性好
- 目标程序：

  - 规模小、速度快

---

*前端与后端：*

- 前端：

  - 与源语言有关、与目标机无关

    > 词法分析、语法分析、语义分析与中间代码生成、与机器无关的代码优化
    >
- 后端：

  - 与目标机有关的部分

    > 与机器有关的代码优化、目标代码生成
    >

*编译器的实现与T形图：*

- 编译器的实现思想：

  - 自展：先实现**语言子集**编译器，再用子集编译更大的集合，直至整个语言
- T形图：

  - 内容：描述了**源语言**经编译程序到**目标语言**的过程

    ```
     --------------------------------          
     |SourceLanguage  ObjectLanguage|            
     ---------                -------       
             |CompilingProgram|
             ------------------
    ```

    > **编译程序(CompilingProgram)的实现语言**可以是高级语言、汇编语言、机器语言，但终究只有**用机器语言实现**才能运行该程序
    >
  - 作用：T形图可以直观描述语言**移植**、**新语言编译**等问题

## 2 程序设计语言及其文法

### 2.1 字母表和串

- **字母表**及其乘积、幂、闭包等运算
- **串**及其连接、幂等运算

### 2.2 文法

文法是一个具有**推导**和**归约**功能的**四元组**：

- **终结符集**（$V_T$）
- **非终结符集**（$V_N$）：与终结符集不相交
- **产生式集**（$P$）

  - 左部属于$(V_T\cup V_N)^+$
  - 右部属于$(V_T\cup V_N)^*$

    > 所以只有**产生式的右部**可以出现$\epsilon$
    >
- **开始符号**（$S$）：至少在产生式左侧出现一次

  - $S\in V_N$

文法主要包括**语法和词法**：

- **语法**：语句的组成规则
- **词法**：单词的组成规则

### 2.3  语言

- 语言的定义

  - 由文法**开始符号**推导出的所有**句子**构成的集合称为**文法生成的语言**。
- 语言的表示/描述

  - 文法解决了**无穷语言的有穷表示**问题。
- 语言的运算

  - 语言有并、连接、幂、闭包等运算。

### 2.4 文法的分类

> 从上至下，**要求依次累加**

- 无限制文法/短语结构文法（0型文法、图灵机）

  - 新增的约束：产生式**左部**至少包含一个**非终结符**
- 上下文有关文法（1型文法、线性界限自动机）

  - 新增的约束：产生式**左部长度小于右部**

    > 当然，也允许**空产生式**的出现，这是个特例
    >
- 上下文无关文法（2型文法、下推自动机）

  - 新增的约束：产生式**左部仅为非终结符**

    > 左部仅有一个非终结符，右部长度大于左部
    >
  - 应用：识别**语言**（语法、语义分析）
- 正则文法（3型文法、有穷自动机）

  - 新增的约束：仅允许**左线性(非终结符**只能出现在最左边)或**右线性**(**非终结符**只能出现在最右边)
    - 产生式右部中，非终结符要么不出现，要么只出现一个
  - 应用：识别**单词**（词法分析）

### 2.5 CFG的分析树

- 分析树是**推导**的图形化表示：

  - 根节点：文法**开始符号**
  - 内部结点：代表**产生式**
    - **左部**：该节点
    - **右部**：子结点从左到右
  - 叶结点：非终结符或终结符
  - **树的产出/边缘**：从左到右排列叶节点
- （句型的）短语：分析树中每一棵**子树的边缘**（若干步推导）

  - 直接短语（简单短语）：高度为2的子树的边缘（一步推导）

    > 注意子树的定义，需要从一个节点**延伸直到叶子节点**才叫子树，而且高度要大于等于2
    >
  - 句柄：句型的**最左直接短语**/最左边高为为2子树的边缘

    > 不同子树的边缘可以相同，但**短语不必重复**。不过，对于出现在树中不同位置的**相同文法符号**，在短语中应当**区别**对待，可以用**下标**来区分它们
    >
- 二义性文法与消歧规则

  - 二义性文法：文法可以为某个句子生成多棵分析树
  - 消歧规则：人为规定一些**优先级**关系

### 2.6 程序设计语言

- 概念
  - 程序设计语言(ProgrammingLanguage)：组成程序的**所有语句**的集合
  - 程序(Program)：满足**语法**规则的**语句序列**
  - 语句(Sentence) ：满足**语法**规则的**单词序列**
  - 单词(Token) ：满足**词法**规则的字符串

## 3 词法分析

### 3.1 正则表达式

- 正则表达式是描述**正则语言**的**更紧凑**的表示方法，它可以**递归构建**
- 与**正则文法、有穷自动机**等价

  > 正则表达式很**简洁**；
  >
  > 正则文法方便文法**性质**的证明；
  >
  > 有穷自动机没那么抽象，方便**实现**；
  >
- 有自己的**代数定律**

### 3.2 有穷自动机

> 核心就是：`状态 + 输入 + 转换`

- 有穷自动机（FA）：

  - 一种处理系统的数学模型。这种处理系统由**输入带、读头、有穷控制器**构造，可以根据当前**状态**和**输入**转入下一状态。
  - FA有其定义/接收的**语言**
  - FA遵循最长子串匹配
- DFA：一种代表FA模型的**五元组**

  - **有穷状态集**（S）
  - **输入字母表**（$\Sigma$）

    > $\epsilon\notin\Sigma$
    >
  - **转换函数**（$\sigma$）：$S\times\Sigma\rarr S$
  - **开始状态**（$s_0$）
  - **接收状态集合**（$F$）
- NFA：一种代表FA模型的**五元组**

  - **有穷状态集**（$S$）
  - **输入字母表**（$\Sigma$）
  - **转换函数**（$\sigma$）：$S\times\Sigma\rarr 2^S$

    > $\epsilon-NFA$与$NFA$的区别就在于转换函数：$S\times(\Sigma\cup\{\epsilon\})\rarr 2^S$
    >
  - **开始状态**（$s_0$）
  - **接收状态集合**（$F$）

### 3.3 RE与FA的转换

- $RE\rarr NFA$：**分解、递归**

  - RE与NFA的对应规则
- $NFA\rarr DFA $：**状态转换表**

  - 子集构造法

### 3.4 词法单元token

- 概念：

  - 词法单元token是源程序中**单词的机内表示**，由**种别码和属性值**构成
- 种别码：

  - 记录单词**类型**
  - 一词一码：关键字、运算符、界限符
  - 一型一码：常量、运算符
  - 多词一码：标识符
- 属性值：

  - 记录单词**字面值**
  - 一词一码：**不需要属性值**
  - 一型一码：用**属性值区分**同一类型的单词
  - 多词一码：用属性值记录**无法枚举**的标识符字面值

### 3.5 词法分析器

- 词法分析器的功能

  - 词法分析器扫描源程序字符串，识别**单词**，确定类型，生成单词(***token***)串

    - 根据**词法规则**识别及组合单词，进行词法检查
    - 对**数字**常数完成数字字符串到**二进制数值**的转换
    - 预处理：删去**空格**字符和**注释**

      > 给人看的，对**机器**无意义
      >
- 词法分析器的工作

  - 输入缓冲区（Look ahead）：设置一个单词开始指针和扫描指针，**一前一后**，中间的部分是要识别的单词
  - 识别出关键字后需要登记符号表

### 3.6 词法分析阶段的错误处理

- 错误类型

  - **单词拼写**错误
  - **非法字符**
  - 不封闭
  - 重复声明
- 错误恢复与续编译：错误处理程序

  - 调用时机：**当前状态与当前输入信息为空**
  - 处理方式：查找已扫描字符串的最后一个**终态字符**

    > 终态指的是自动机终态
    >

    - 找到了：识别成一个**单词**，回到初态
    - 没找到：错误恢复策略（**恐慌模式**）
  - 恐慌模式：从**剩余输入中删除字符**直到遇到正确字符

## 4 语法分析

### 4.1 句法分析概述

- 主要任务:

  - 从***token***序列**中，识别**语法成分/短语**，构造**语法分析树**，指导**翻译过程
- 基本方法:

  - 自顶向下: 自顶向下构造语法分析树, 根据**输入符**，选择合适的**产生式**推导**最左非终结符**, 直到推导出完整的输入串
    - 递归下降分析法
    - 预测分析法
  - 自底向上: 自底向上构造语法分析树, 根据**输入符,** 选择合适的**句柄**进行归约, 直至将输入符串归约为文法开始符号
    - 算符优先分析法
    - LR分析法

### 4.2 自顶向下分析概述

*自顶向下分析的基本思想与主要问题：*

- 基本思想

  - 自顶向下构造语法分析树, 根据**输入符**，选择合适的**产生式**推导**最左非终结符**, 直到推导出完整的输入串
  - 最左非终结符也是当前语法分析树的**最左非终结符节点**, 代表**最左推导**
  - 替换后会在语法分析树上**生成子节点**
- 主要问题

  > 本质上是**文法改造问题**，都是基于**上下文无关文法**的改造
  >

  - 二义性问题

    - 问题描述：文法中存在句子有不只一棵**语法分析树**

      > 注：不存在算法判断一个上下文无关文法是**无二义性**的，但可以给出一组**充分条件**，满足充分条件的文法是无二义性的
      >
      > 做题的时候尝试去寻找同一句型的多棵分析树即可
      >
    - 解决方法：改造文法，引入**细粒度的文法变量**；或人为规定优先级

      > 例如：
      >
      > - 解决加法和乘法优先级问题：引入**项**和**因子**的文法符号
      > - 解决 `if`匹配问题：引入**“匹配”**和**“不匹配”**的文法符号
      >   - `if-else`的就近原则
      >
  - 回溯问题

    - 问题描述：多个**候选式**存在**公共前缀**
    - 解决方法：改造文法；提取左公因子（本质是在推迟决定）

      - 通过**FIRST集**和**FOLLOW集**判断是否会出现回溯
      - 提取左公因子的一般形式：`S->cA|cB ----> S->cS' S'->A|B`

        > 把相同的留着，不同的交给新的文法变量去推
        >
  - 左递归问题

    - 问题描述：直接左递归、间接左递归
    - 解决方法：消除左递归

      - 消除**直接左递归**的一般形式：$A\rarr A\alpha_1|A\alpha_2|...|A\alpha_n|\beta_1|\beta_2|...|\beta_m $

        - 转化为：

          - $A\rarr\beta_1A'|\beta_2A'|...|\beta_mA'$
          - $A'\rarr\alpha_1A'|\alpha_2A'|...|\alpha_nA'|\epsilon$

            > 把不左递归的先推出来，原左递归的交给新的文法符号改成右递归，再加空
            >
            > 本质上是将左递归转换成了**右递归**，付出的代价是引入一新的**非终结符**和**空产生式**，注意最后的**空产生式**
            >
      - 消除**间接左递归**：先代入到最大编号，再消除直接左递归

        - 给所有产生式**左部编号**，按编号**从小到大遍历**
        - 如果出现**左部编号大于右部开头编号**，则出现左递归
        - 若出现左递归，将相关产生式**代入到左部编号最大的产生式**中，转换成**直接左递归**，然后消除直接左递归

---

*预测分析法的基本思想：*

- 预测分析:

  - 一般的自顶向下分析往往会因为**产生式选择的不确定性**而需要**回溯**，但**预测分析**就不需要回溯，它依据**预测分析表**，是一种**确定的自顶向下分析方法**
- 文法改造与检查：

  - 并不是所有文法都直接适用于自顶向下的分析，文法转换就是要**改造这些文法**以使其适合**自顶向下的分析**。

    - 消除文法的二义性
    - 消除文法的回溯
    - 消除文法的左递归
  - 改造文法后，还要检查文法是否为LL(1)的

---

*递归下降分析法的基本思想：*

- 根据文法产生式，定义可以递归调用的函数

### 4.3 预测分析法

> 总结
>
> 1. 构造与检查文法
>
>    1. 构造一般文法
>    2. 改造文法：消除二义性、消除左递归、消除回溯
>    3. 检查是否为LL(1)文法
> 2. 设计算法
>
>    1. 构造**预测分析表**
>    2. 非递归的预测分析：下推自动机

*重要集合的引入与计算：*

- FIRST集

  - 定义：文法符号(串)经过**若干步推导**得到的所有符号(串)的**首终结符**的集合

    - 若干步：零步、一步、多步

      > 后面出现的所有“推导”，若无特殊说明，均指的是“经若干步推导”
      >
    - 特例：若能推导出$\epsilon$，则$\epsilon$也加入FIRST集
  - 计算：不断包含右部“开头”符号的FIRST集

    - 终结符的FIRST集**：**只包含该终结符一个元素的集合
    - **非终结符FIRST集**：**不断包含右部“开头”符号的FIRST集**

      - 右部开头是**终结符**或右部为**空**：直接包含终结符或$\epsilon$
      - 右部开头是**非终结符**：
        - 包含该非终结符的FIRST集（先不包括$\epsilon$）
        - 同时若该非终结符能推导出$\epsilon$，则继续加入右边紧邻符号的FIRST集，直到不能推导出$\epsilon$
        - 若都能推导出$\epsilon$，再将$\epsilon$加入FIRST集中

      > **文法符号串的FIRST集：**
      >
      > - 从左向右看，加入**第一个符号的FIRST集**
      > - 若第一个符号能推导出$\epsilon $，就累加下一个**符号的FIRST集**，直到不能再推出$\epsilon$
      > - 如果都能推导出$\epsilon $就再加入$\epsilon $
      >
- FOLLOW集

  - 定义：是**非终结符**相关的一种集合，即**推导**过程中可以**紧跟在该非终结符右侧**的**终结符**的集合
  - 计算：不断包含**右侧的FISRT集**和作为右部结尾时**左部的FOLLOW集**
    - 将**结束标记**加入开始符号的FOLLOW集中
    - 加右边的FIRST集：单看**产生式右部**，跟在某一非终结符**后面的符号串的FIRST集**加入该非终结符的FOLLOW集中，但不能加入$\epsilon$
    - 加左部的FOLLOW集：看**整条产生式**，**右部结尾**的非终结符，以及可能因右方非终结符推导出$\epsilon$而**变成右部结尾**的非终结符，其FOLLOW集要**包含**左部非终结符的FOLLOW集
- SELECT集

  - 定义：是产生式相关的一种集合，即推导过程中可以选择该产生式时的**输入符号**的集合
  - 计算：产生式的SELECT集的计算
    - 若是空产生式，则为**左部**非终结符的**FOLLOW集**
    - 若非空产生式，则为**右部**符号串的**FIRST集**，不过若这个FIRST集中包含$\epsilon$，就要去掉$\epsilon$再并上左部的FOLLOW集

---

*适合预测分析的文法：*

> 目标：构造不需要回溯、可用于预测分析的文法（前提是要先适用于自顶向下分析）

- S_文法

  - 产生式**右部**以**终结符**开始（不包含$\epsilon$产生式）
  - 同一非终结符各个候选式的**首终结符**都不相同
- q_文法

  - 产生式**右部**或为$\epsilon$，或以**终结符**开始
  - 具有相同左部的产生式有**不相交的可选集**
    - 可选集：可以使用该产生式推导时的**输入符号**集合，称为这个产生式的可选集
- LL(1)文法：同一非终结符各个**产生式**的**SELECT集**互不相交

  > 从**左**向右扫描，构造最**左**推导
  >

  > 下面这三条限制就是为了保证“同一非终结符各个产生式的**SELECT集**互不相交”，是**所有非终结符**都要满足的
  >

  - 同一非终结符的候选式的FISRT集互不相交
  - 只能有一个候选式可以推出空，若存在这样的一个候选式，则还要求左部的FOLLOW集与所有候选式的FIRST集互不相交

---

*预测分析法的工作：*

- 预测分析的格局/表驱动的下推自动机

  - 控制程序：包含通用的控制**算法**

    > 例如接下来要讲的表驱动的预测分析算法
    >
  - 栈：分析栈，指导**语法分析树**的形成。初始时栈底符号为#，栈顶符号为文法开始符号

    > 预测分析中，栈中的内容就是**句型**
    >
  - 输入：**输入**缓冲区，#为输入串结束符
  - 表：**预测分析表M**

    - 内容：行是**非终结符**，列是**输入符号和#**，表项是以行非终结符为左部的产生式

      > 列输入符号要包含于表项产生式的SELECT集
      >
    - 使用：栈顶非终结符作为行，当前输入作为列，找到表项中的产生式进行推导
- 预测分析表的构建

  - 对于任意产生式，只要输入符号在右部的FIRST集中，就可以选择
  - 同时对于右部能推出空的产生式，输入符号在左部的FOLLOW集中时也可以选择
- **表驱动的预测分析法/**非递归的预测分析法：

  - 借助**下推自动机和预测分析表**
  - 对比输入符号与栈顶符号，直到**栈顶和输入**都为结束符
  - 若栈顶符号为**终结符**

    - 二者**相等**，则弹栈，消耗输入符号，读头后移
    - 二者不相等，则报错
  - 若栈顶符号为**非终结符**：查询预测分析表得到**产生式**，左部弹栈，右部入栈（**自右向左**入栈）不消耗**输入符号**

---

*预测分析法的错误处理：*

- 错误检测

  - 最左/栈顶**终结符**与当前**输入符号不匹配**
  - 最左/栈顶**非终结符**与当前输入符号在**预测分析表**中**无可用产生式**
- 错误恢复：恐慌模式

  - 最左/栈顶**终结符**与当前输入不匹配时：直接忽略输入符号（删除）
  - 最左/栈顶**非终结符**与当前输入符号在**预测分析表**中无可用产生式：

    - 若输入符号不在该非终结符的**FOLLOW集**中，则忽略输入符号（删除）
    - 若输入符号在该非终结符的**FOLLOW集**中（同步词法单元），则忽略/弹出该非终结符

      > FOLLOW集本质就是非终结符**推出空**时的SELECT集
      >

### 4.4 递归下降分析法

- 文法：要求文法是LL(1)的
- 分析：从文法**开始符号的产生式**开始，遍历右部符号（即**调用文法开始符号的过程**）

  > 遍历符号的过程中，每次取得一个输入，终结符消耗输入，非终结符根据输入选择产生式
  >

  - 若为终结符，则必须等于当前输入符号，否则报错
  - 若为非终结符，则“递归”调用**该非终结符对应的过程**

    > 非终结符对应的过程：
    >
    > - 若有**多条产生式**，先根据输入和SELECT集选择产生式
    > - 遍历产生式右部符号，若是终结符，则当前输入必须与之相等，否则报错；若是非终结符，则调用其过程
    >
  - 最后一个输入符号必须是终结符

### 4.5 自底向上分析概述

*自底向上分析的基本思想与主要问题：*

- 基本思想

  - 自底向上构造语法分析树, 根据**输入符,** 选择合适的**句柄**进行归约, 直至将输入符串归约为文法开始符号

    - 句柄：当前句型的**最左直接短语**
    - 归约句柄：**最左归约**
  - 移入-归约的思想

    - 自底向上分析也叫**移入-归约分析**

      > 借助**栈**来理解
      >
    - 移入：将**输入符号**压入栈
    - 归约：从栈中依次**弹出**能构成**产生式右部**的若干个符号，然后将**左部压入栈**（最左归约）

      > 最左归约称为规范归约、最右推导称为规范推导，每次用于归约的符号串称之为**句柄**，也就是**产生式右部**
      >
- 主要问题

  - 何时移入、何时归约、归约时用什么归约
  - 移入-归约分析中的关键问题是**正确识别句柄**
- 系统框架

  - 控制程序
  - 栈：分析栈

    > 自底向上分析中，**栈和输入**中的内容组合起来是(规范)句型，栈中的内容只是句型的**前缀**
    >
  - 输入：输入缓冲区
  - 表：指导**语法分析树**的形成，确定**移进和归约**的时机

---

*优先法的基本思想：*

- 优先级的概念：优先级指的是**归约的优先级**
- 优先级的作用：确定何时移进何时规约

  - **栈顶**最近的终结符优先级**小于或等于输入**符号：移入
  - **栈顶**最近的终结符优先级**大于输入**符号：归约
    - 归约的句柄是从栈顶到第一次优先级**小于**输入的位置（不包括）
- 核心问题：优先级的确定

---

*状态法/LR分析的基本思想：*

> 从**左**到右扫描，反向构造最**右**推导

- **状态**：

  - 用**状态**表示**句柄识别的进展程度**

    > 状态的可视化表示就是在产生式右部插入一个圆点，代表**离可以使用该产生式归约**还差什么符号，**圆点右边的符号**就是需要的符号
    >
  - 移进状态：圆点后面是终结符
  - 待约状态：圆点后面是非终结符
  - 归约状态：圆点后面没有符号
- **栈**：

  - 有两个栈，**状态栈与符号栈**，它们是平行的（栈中**元素个数保持相等**）
- **分析表**：

  - 只要构造出正确的**分析表**就可以直观且快速地识别了，分析表的概述如下：
  - 内容：

    - **一行**对应一个**状态**，一个状态的**一条边**对应于该行的**一个表项**

      > 这里的**边**指的是自动机中的边
      >
    - **一列**对应一个**文法符号**，终结符和结束符在**ACTION列组**，非终结符在**GOTO列组**
  - 应用：

    - 从状态栈只有初始状态0、符号栈只有结束符$开始，根据**当前状态(行)和输入符号(列)**找到表项，执行对应的操作，直到读取输入后找到的表项为acc或err

      > acc时，栈中为S，输入缓冲中为#
      >
    - 表项中，$s_n$代表将**所在列对应符号和状态n**同时压入栈符号栈和状态栈；$r_n$代表使用第n个产生式归约，同时弹出**产生式右部**符号(串)和与其**平行的状态**，并压入**左部非终结符**，再根据**当前栈顶状态**和**该非终结符**找到GOTO列组的项k，这代表着再**将状态k压入栈**；acc代表成功识别，err代表出错

      > 所以，**构造出文法的分析表**是LR分析的关键
      >

### 4.4 算符优先分析法

*适合算符优先分析的文法：*

- 算符文法：

  - 文法中不存在具有**相邻非终结符**的产生式
- 算符优先文法：

  - 定义：可以根据产生式推断出**不矛盾优先级**关系的**算符文法**
  - 终结符优先级的确定：

    - **相邻或只间隔一个非终结符**，则优先级相等
    - 经由非终结符**推导**至少一步后**相邻或只间隔一个非终结符**，则被推导出的优先级更高，且应当认为**左边**的处于**栈**中，**右边**的处于**输入缓冲**中

      > 对于不能通过产生式判断优先级的算符文法，也可以**人为规定优先级**
      >

---

*算符优先矩阵：*

- FIRSTOP与LASTOP

  - 非终结符的FIRSTOP集：该非终结符经过至少一步推导得到的**串首终结符或**去掉串首的**一个非终结符**后成为串首终结符的集合
  - 非终结符的LASTOP集：该非终结符经过至少一步推导得到的**串尾终结符或**去掉串尾的**一个非终结符**后成为串首终结符的集合
- 算符优先矩阵

  - 内容：

    - 行：栈内符号
    - 列：输入符号

      > 注意行列不要颠倒；也可以包括#，栈中的#对应于FIRSTOP，输入中的#对应于LASTOP
      >
  - 填写：

    - 遍历所有产生式右部的所有相邻符号，确定优先级
    - 应当认为左边的处于栈中，右边的处于输入缓冲中
- 优先函数

  - 构造方法：

    - 通过算符优先矩阵规定的偏序关系，构造DAG，计算拓扑排序，基于拓扑排序构造优先函数
  - 优点：节省存储空间
  - 缺点：错误检测能力降低

    > 详见笔记仓库
    >

---

*算符优先法的素短语：*

- 素短语：**含终结符**且不含有更小**含终结符短语**的短语
- 算符优先法归约的是**最左素短语**，并非**最左直接短语**

### 4.5 LR分析法

> ⭐️LR系列的相关概念较多，暂不探讨定义这些概念的内在原因，只要能将其**应用到问题中**即可

*LR(0)分析：*

- LR(0)相关概念

  - **增广文法**：新增开始符号，它能推导出原开始符号（$S'\rarr S$）

    > 增广文法让文法**开始符号**仅出现在一个产生式的**左边**，这样分析器**只有一个接受状态**
    >
  - **项目**：项目描述了**句柄识别的状态**

    - 移进项目
    - 待约项目

      > 开始符号对应的待约项目称为初始项目（$S'\rarr\cdot S$）
      >
    - 归约项目

      > 开始符号对应的归约项目称为接收项目（$S'\rarr S\cdot$）
      >
      > 产生式$A\rarr\epsilon$只生成一个项目$A\rarr\cdot$
      >
  - **后继项目**：同属一个产生式但圆点只差一个符号，圆点在后的是后继项目
  - **等价的项目/项目集闭包**：对于一个**待约**项目，它的等价项目就是，以该待约项目**圆点后面的符号**为**左部**的所有产生式将圆点放在**右部第一个符号前**得到的项目；被等价推出的**待约**项目可以继续等价推出，直到不能再推出新的待约项目。这样推出的所有项目都放在一个集合中，这个集合就是**项目集闭包**。

    > 对于移进项目和归约项目，它们可以被待约项目等价推出，但不能等价推出别的项目。如果它们不能由某个待约项目等价推出，则它们没有等价项目
    >
  - 项目集对应于**文法符号X**(包括终结符和非终结符)的**后继项目集闭包**（`GOTO(I, X)`函数）：项目集中**圆点右紧邻符号为X**的每一个项目的**后继**项目集闭包的并
- LR(0)自动机与分析表

  - 自动机的构造

    - 初始项目（$S'\rarr\cdot S$）的**项目集闭包**构成**状态0**
    - 对于**每一个现有状态**，求其对于**每一个文法符号(包括终结符和非终结符)**的后继项目集闭包（`GOTO(I, X)`），若 `GOTO(I, X)`不为空，则将其作为一个新的状态（如果是已经存在的状态就不必当成新状态了），并生成一条当前状态指向 `GOTO(T, X)`对应状态的**有向边**，边上的符号为当前文法符号
    - 循环执行2**直到不再增加有向边**
  - 分析表的构造

    - 行：所有**状态；**列：ACTION列（所有终结符+结束符）和GOTO列（除了增广的非终结符）
    - **接收项目**是单独在一个状态里，对应**接收状态**，在表中与结束符$形成表项acc
    - 对于一个状态i（一行）

      > 一个状态中若既有**归约项目**又有其他类型的项目，则会出现冲突，这里暂不考虑
      >

      - 出边上是**非终结符**的，对应该行的**GOTO表项**，为有向边指向的状态编号j
      - 出边上是**终结符**的，对应该行的**ACTION表项**，为有向边指向的状态$s_j$
      - 若**没有出边**，或者说状态中**只有一个归约项目**，则该行的ACTION表项全为$r_k$（k为该归约项目对应的**产生式编号**）
- LR(0)会有**移进/归约**冲突和**归约/归约**冲突

  > 总得来说，就是该不该归约的问题
  >

  - 对应到自动机中，就是一个状态中**同时存在归约项目和其他类型项目**，或者同时存在**多个归约项目**，导致遇到下一个输入时无法判断执行什么动作
  - 对应到分析表中，就是ACTION列组的**一个表项**会有**两个可选值**
  - 出现问题的本质原因是，LR(0)分析没有**向前查看符号**，没考虑**上下文环境**

---

*SLR分析：*

- SLR分析基本思想

  > S：Simple，仅通过FOLLOW集化解冲突
  >

  - 是对LR(0)分析的改进，**在LR(0)分析的基础上**，不是**子成分**都全了就能归约的，因为归约后左部符号的**FOLLOW集**中可能没有该输入符，也就是归约后的符号可能不是**待分析句子中的一个成分**
  - 当遇到LR(0)中所述冲突时，要考察两种集合(是两种，不是两个。第一种里只有一个，第二种里可以有多个)：

    - 第一种是状态中**所有移进/待约项目**圆点右侧符号构成的集合，
    - 第二种是状态中所有**归约项目**对应产生式左部非终结符的**所有FOLLOW集**。
  - 当这些集合两两不相交时：

    > 若不能做到两两不相交，则说明SLR无法解决这种冲突
    >

    - 若**输入符号**在圆点右侧符号构成的集合中，则执行对应的移进ACTION；
    - 若**输入符号**在某个归约项目左部的FOLLOW集中，则执行对应的归约ACTION。
    - 其他情况报错
- SLR自动机与分析表

  - 自动机的构造：与LR(0)一样的
  - 分析表的构造：在LR(0)构造的分析表基础上，只有**ACTION列的终结符(输入符号)**在对应状态中归约项目左部符号的**FOLLOW集**中时，才进行归约，否则的话，要么是**移进**，要么**表项为空**

    > 若这样做之后一个表项中还是会留下多个动作，则说明SLR无法解决这种冲突
    >
- SLR分析中的冲突

  - 上述的两种集合不能做到**两两不相交**
  - 本质原因是，对于归约项目，输入符号在其左部**FOLLOW集**中，只是能归约一个**必要条件**，并非充分条件

---

*LR(1)分析：*

- 基本思想与概念

  - 在LR分析的**特定位置**，对于非终结符A，并非FOLLOW(A)中的所有符号都可以接在A后面，所以并不是输入符在FOLLOW(A)中了就可以使用以A为左部的这条产生式进行归约，我们需要找到**非终结符A在特定位置的后继符**

    > 也就是说，需要考虑程序**上下文**，而LR(1)就是在考虑**下文的第1个符号**
    >
  - 规范LR(1)项目：$A\rarr\alpha\cdot\beta, a（第一分量,第二分量）$

    - 第一分量：右部带圆点的产生式（就是之前对于项目的定义）
    - 第二分量：展望符，代表当前状态下A后面可以紧跟的终结符。对于归约项目（$A\rarr\alpha\cdot,a$），代表输入符号为a时才能使用该产生式归约

      > 对于移入项目和待约项目（$A\rarr\alpha\cdot\beta, a且\beta\ne\epsilon$），**展望符与之无关**，但为了定义的完整，把它写出来了
      >
  - **等价**LR(1)项目/**展望符**的计算：

    - 第一分量：就是之前定义过的**等价项目**
    - 第二分量/展望符：要看等价项目产生式的**左部**在原项目中**右边的符号(串)**$\beta$。若$\beta$能推出空（或者$\beta$本身就是空的），则直接继承相同的展望符构成项目, 同时，对于$FIRST(\beta)$中的每个终结符，都可以再作为**展望符**与相同的**第一分量**构成一个等价的项目

      > 从计算展望符的角度讲，就要从初始项目$S'\rarr\cdot S,\$ $出发按照自动机的构造方法去计算了，移进的时候展望符不变；第一分量相同的项目，可以合并到一起写，**展望符用/隔开**，但要知道这是多个项目
      >
- LR(1)的自动机和分析表

  > 相比于LR(0)，LR(1)对于CLOSURE、GOTO、项集族、自动机、分析表构造算法都做了适合于**展望符与归约项目**的修改
  >

  - 自动机的构造：从初始项目$S'\rarr\cdot S,\$ $开始，与LR(0)的生成规则类似，只是在计算项目等价的时候要考虑**展望符**
  - 分析表的构造：

    - 对于不涉及归约项目的状态，处理方法与LR(0)相同
    - 对于涉及**归约项目**的状态，只有ACTION列(输入符号)是状态中归约项目的**展望符**时才能规约(且必须归约)

      > 之前构造SLR的时候，是遇到左部FOLLOW集中的符号都能规约
      >

---

*LALR分析：*

- LALR基本思想与概念

  - LR(1)的状态过多，其中有些状态是可以合并的
  - **同心项目集**（同心状态）：只保留第一分量时(重复的只留一个)，完全相同的项目集
  - 同心项目集是可以合并成一个状态的，其实是在对**展望符**进行合并
- LALR的自动机与状态表

  - 自动机：在构造出的LR(1)自动机基础上，合并同心项目并修改边
  - 分析表：与LR(1)的构造方法相同
- LALR的问题

  - 归约-归约冲突：同一个输入符，不知道该用状态中的哪个产生式归约了，因为它们的**展望符**都相同
  - 推迟错误发现：合并同心项集后，虽然不产生冲突，但可能会**推迟错误的发现**

    > LALR分析法可能会作多余的**归约动作**，但绝不会作错误的**移进操作**。因为LALR其实是在合并展望符集合，而展望符与归约有关，与移进无关
    >
- LALR的特点

  - 形式上与LR(1)相同，都有**展望符**
  - 大小上与LR(0)/SLR相当，因为**合并了状态**
  - 分析能力上，SLR<LALR<LR。相比于SLR，LALR细化了状态；相比于LR(1)，LALR会延迟错误的发现。

---

*错误处理：*

- 当没有可选动作时，在符号栈中寻找上一个**归约出来的非终结符**，然后丢弃输入符号直至当前输入在该非终结符的FOLLOW集中，然后移进该输入，再压入一个与该非终结符平等的状态，继续分析

  > 本质上是找到上一次正确归约的语法分成，跳过当前出错的语法成分，继续分析下一个语法成分
  >

## 5 语法制导翻译

> 对产生式的理解：在编译原理中，产生式往往有着具体到代码层面**实际意义**，产生式的**结构/应用场景**决定了其在翻译过程中的实际意义
>
> 对语义分析的理解：语法分析中用产生式进行推导/规约，其实就是在**分析语法结构**，找到结构后就要做**翻译动作**，进行一些**静态语义检查**和**中间代码生成**

### 5.1 相关概念与基本思想

- 概念：将**静态语义检查**和**中间代码生成**结合到语法分析中进行的技术称为**语法制导翻译**
- 基本思想：语法制导翻译的基本思想是，用**产生式**代表**语法规则**，再为产生式关联**语义规则**，在**构造语法分析树**时通过语义规则**计算语义属性值或执行某些动作**
- 语法制导定义SDD：

  > 对上下文无关文法的推广
  >

  - **语义属性**：为每个文法符号设置若干**语义属性**

    - **语义属性的作用**：在推导/规约过程中**传递信息**

      > 不传递的话之后要用就找不到了
      >
  - **语义规则**：为每条产生式关联若干**语义规则**，语义规则用于**计算语义属性值**
- 语法制导翻译方案SDT：

  - **语义动作**：在SDD的基础上，直接**将语义规则嵌入产生式右部**，称为**语义动作**

    > 将**属性值计算**的工作解耦给**语义动作**
    >

    - **语义动作的执行：**在产生式中的**位置**决定了其**执行时间**
  - **SDT与SDD的关系**：SDT可以看作是SDD的**具体实施方案**，有SDT就能按照一定的**工作流程**计算所有语义属性值

    > SDT通用的实现方法：首先建立一棵**语法分析树**，然后按照**从左到右的深度优先顺序**来执行这些动作
    >

### 5.2 语法制导定义

- 文法符号的属性：

  - **综合属性**：
    - 非终结符的综合属性：只能通过**子结点**或其本身的属性值定义
    - 终结符的综合属性/**固有属性**：由词法分析器提供的词法值（**token属性值**）
  - **继承属性**：
    - 非终结符的综合属性：只能通过**父结点、兄弟结点**或其本身的属性值定义
    - 终结符没有继承属性
- 副作用与属性文法：

  - **副作用**：有的语义规则目的是产生**副作用**，用到其他结点的属性值，但不计算新的属性值，可以理解成在计算**虚属性**

    > 比如打印、在符号表中创建记录并设置类型等等
    >
  - **属性文法**：没有副作用的SDD称为**属性文法**，仅通过其他属性值和常量定义属性值
- 属性求值方法：

  - 属性求值遵循的顺序：**依赖图的拓扑排序**
  - 依赖图：依赖图是描述分析树**结点属性的依赖关系**的有向图，以语法分析树为基础图，若结点X有属性a，则将a也作为依赖图中的结点（画在X旁边）；若属性X.a的值计算依赖于Y.b，则添加一条Y.b指向X.a的有向边；如果有“虚属性”，也可以画在结点旁边。
  - 求值的可行性：一个SDD不一定存在可行的求值顺序，有可能发生**循环依赖**
- 属性定义：

  - SDD的有用子类，一定存在一个**求值顺序**
  - **S-属性定义/S-属性文法/S属性的SDD**：只具有**综合属性**的SDD

    - 属性求值方法：S-SDD可以按照语法分析树**自底向上**的顺序计算各属性值
    - 在语法分析中的实现：S-SDD可以**在自底向上的语法分析**中实现
  - **L-属性定义/L-属性文法/L属性的SDD**：每个属性要么是**综合属性**，要么是只依赖 **父结点继承**属性、**左兄弟**结点属性、**本身**属性 的**继承属性**（但本身的属性不能形成**环路**）

    > 语法分析均为**最左推导或最左归约**，所以要求**左兄弟**
    >

    - 属性求值方法：从左到右遍历子结点，在遍历到符号前，计算其**继承属性**，遍历结束后计算父节点**综合属性**

### 5.3 语法制导翻译方案

- 基本思想

  - 语法制导翻译方案也叫**翻译模式**，给出了使用语义规则进行计算的**顺序**
- SDD向SDT的转换

  - S-SDD转换为SDT：
    - 将每个语义动作都放在**产生式右部的最右端**，代表在**规约**时计算属性值
    - 如果S-SDD的**基本文法**可以使用LR分析技术，那它的SDT就可以在LR分析过程中实现
  - L-SDD转换为SDT：
    - 计算产生式左部符号**综合属性**的语义动作放在**产生式右部的最右端**
    - 计算产生式右部非终结符**继承属性**的语义动作插入**非终结符紧邻左边**
- S-SDD的自底向上翻译

  - 扩展LR语法**分析栈**：在分析栈中附加一个域存储**综合属性**（值或指针），与文法符号平行（语义栈）
  - 分析栈的工作：在**规约**时执行语义动作，找到栈中对应位置的依赖，计算属性值，存入附加域
- S-SDD的预测分析翻译

  - 文法改造

    - 消除左递归

      - 先消除左递归，再添加语义规则
      - 先添加语义规则，再消除左递归，并**添加新的语义规则**

        > 这就需要引入**继承属性**并插入**语义动作**，传递信息
        >
  - 其他部分与L-SDD的翻译一致
- L-SDD的预测分析翻译

  - 文法改造
  - 扩展预测分析栈

    - 继承属性在即将出现时计算，存放在**与非终结符平行的记录 `A`**中（横向扩展、语义栈）
    - 综合属性在子结点分析完后计算，**新增一条综合记录 `Asyn`**存放（纵向扩展）
    - 增加一种**动作记录 `action`**，指向要执行的动作（纵向扩展）
  - 分析栈的工作

    - 依然按照右部**从右向左**的顺序入栈，**综合记录 `syn`先**于本身记录入栈，动作记录 `action`同样按照所处位置入栈

      > 往往会给语义动作对应的动作记录取一个简洁的**别名**
      >
    - 栈内元素的出栈行为：

      - 栈顶为**动作记录**时，直接出栈并执行对应动作；
      - 栈顶为**综合记录**时，直接出栈并将**综合属性值传递**给栈内的特定语义动作；
      - **变量本身记录**出栈时，若有继承属性，则要将**继承属性值传递**给入栈的特定语义动作；
      - **终结符**出栈时要将**综合属性值**传递给栈中的特定语义动作

        > 这里的“传递”具体到程序上就是 `stack[top+-n].xxx=stack[top].xxx, top=top+-n`，其中 `top+-n`对应了语义动作出现的位置
        >
    - **综合属性**的计算：综合属性在对应产生式右部**最右端语义动作出栈**时计算
    - **继承属性**的计算：变量本身记录的继承属性在对应产生式**紧邻左边动作出栈**时计算

      > 这里的“计算”具体到程序上，也是给 `stk[top+-n]`赋值，涉及到一些计算，其中 `top+-n`对应了综合记录或变量本身记录出现的位置
      >
- L-SDD的递归下降分析翻译

  - 文法改造
  - 在**递归下降分析**基础上，将非终结符的过程扩展为**函数**，参数为左部的**继承属性**，返回值为左部的**综合属性**

    > 递归的预测分析中过程调用的框架在这里要沿用
    >
  - 对右部符号的每个属性都设置**局部变量**

    > 函数返回值由综合属性的局部变量接收
    >
  - 将每个**语义动作**的代码依次加入函数体，使用对应的变量书写其动作逻辑

    - 继承属性局部变量的计算：按照**语义动作**计算并赋值给对应局部变量
    - 综合属性局部变量的计算：调用非终结符对应的函数

      > 终结符的话直接从token中取值
      >
- L-SDD的自底向上翻译

  - **修改文法**以适应自底向上

    - 用各个“**标记非终结符**”替换**内嵌**的各个**语义动作**，每个标记非终结符都对应一条空产生式
    - 标记非终结符的空产生式最右端添加新语义动作

      - 将原动作依赖的属性作为**标记非终结符的继承属性**
      - 将原动作要计算的属性作为**标记非终结符的综合属性**来计算

        > 可以证明，如果一个文法是LL的，那么标记非终结符可以插入到产生式的任何位置，并且得到的文法是LR文法
        >
  - 分析栈的工作

    - 与S-SDD基本一致，原继承属性的计算变成了**对标记非终结符综合属性的计算**
    - 计算标记非终结符时，要结合原产生式和继承属性的实际情况确定依赖位置和计算方式

## 6 语义分析与中间代码生成

> 这一小节十分需要用具体的例子辅助理解，详见编译原理随堂笔记仓库

### 6.0 中间代码的表示形式

- 逆波兰表示
- 三地址码

  - 定义： 每条指令最多只能包含**三个地址**， 两个操作数地址和一个结果地址
  - 指令类型

    - 算术与赋值：`x := y op z`、`x[i] := y[j]`、`*x := &y`

      > **多维数组**需要计算出**一维下标**
      >
    - 跳转

      - 无条件跳转：`goto L`
      - 条件跳转：`if x relop y goto L`、`if x goto L`
    - 过程调用与返回

      - 指明参数：`param x`
      - 过程调用：`y = call p, n`
      - 返回：`return y`
  - 表示形式：四元式

### 6.1 声明语句的翻译

*主要任务/语义动作的主要内容：*

- 类型：通过**类型表达式**，收集**标识符类型**等属性信息

  - 类型检查
  - 辅助翻译
- 宽度和相对地址：由类型表达式计算**宽度**，从而为每个标识符分配一个**相对地址**
- 符号表：将标识符类型和相对地址等信息保存至对应**符号表**。如果是嵌套声明，还要正确构建内层与外层符号表的访问链。

---

*类型表达式(Type Expreessions)：*

- **基本类型**是一种类型表达式，常见基本类型有：

  - `integer real char boolean type_error void`
- 可以给类型表达式命名，**类型名**也是一种类型表达式
- **类型构造符**作用于类型表达式可以构成新的类型表达式

  - 数组构造符 `array(elem_num, type)`

    > 举例：`int[2][3]`对应于 `array(2, array(3, int))`
    >
  - 指针构造符 `pointer(type)`
  - 笛卡尔乘积构造符$\times$：`T1 × T2`
  - 函数构造符$\rarr$：`T1 × T2 × ... × Tn → R`

    - `Ti`是类型表达式，相当于参数
    - `R`也是类型表达式，相当于返回值
  - 记录构造符 `record((N1×T1), (N2×T2), ..., (Nn×Tn))`

    - `Ni`是标识符
    - `Ti`是类型表达式
- 类型的**结构等价**

  - *T*(1)和*T*(2)是相同的基本类型
  - *T*(1)和*T*(2)是将同一类型构造符应用于结构等价的类型上形成的
  - *T*(1)是表示*T*(2)的类型名

---

*声明语句的SDT：*

- 文法符号与综合属性

  - `P`：开始符号
  - `D`：声明语句
  - `T`：标识符类型

    - `T.type`：类型表达式
    - `T.width`：类型宽度
  - `B`：基本类型

    - `B.type`：基本类型
    - `B.width`：基本类型宽度
  - `C`：数组标志

    - `C.type`：数组类型
    - `C.width`：数组类型宽度
  - `id`：标识符

    - `id.lexeme`：构成标识符的字符序列

      > 是词法分析器提供的词法值
      >
  - `num`：整数的正则定义

    - `num.val`：整数值
  - `int`：整型
  - `real`：实型
  - `↑`：指针标志
- 特殊变量

  - `offset`：下一个可用的**相对地址**，有初始值，可设为0
  - `t`和 `w`：将**类型和宽度信息**从语法分析树的B结点传递到产生式

    $$
    C\rarr\epsilon

    $$

    $$
    对应的结点


    > 这里把类型看成由**基本类型+数组标志组成**，所以这两部分之间需要传递信息。如果把类型看成**基本类型或数组类型两类**，就不需要这样传递了
    >

    $$
- 副作用

  - `enter(name, type, offset)`：在符号表中为标识符 `name`创建记录，将 `name`的类型设置为 `type`，相对地址设置为 `offset`
- 语法规则和语义动作(推导角度)

  - 开始：$P\rarr\{a_1\}D$

    $$
    \begin{align*} &a_1:\{\\ &~~~~offset=0\\ &\} \end{align*}

    $$

    > 程序形成前要将 `offset`置为初始值
    >
  - **声明语句**的生成：

    - $D\rarr T~id;\{a_1\}D$

      $$
      \begin{align*} &a_1:\{\\ &~~~~enter(id.lexem,~T.type,~offset);\\ &~~~~offset=offset+T.width;\\ &\} \end{align*}

      $$

      > 声明语句形成后在**符号表**创建记录，并后移 `offset`
      >
    - $D\rarr\epsilon$
  - **标识符类型**的形成：

    - $T\rarr B\{a_1\}C\{a_2\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~t=B.type;\\ &~~~~w=B.width;\\ &\}\\ &a_2:\{\\ &~~~~T.type=C.type;\\ &~~~~T.width=C.width;\\ &\} \end{align*}

      $$

      > **基本类型**形成后用 `t`和 `w`记录**类型和宽度**，以便向后传递；
      >
      > **标识符类型**形成后要设置**类型表达式和宽度**
      >

      > 另一种方案(归约角度)：
      >
      > - `T -> int {T.type = int, T.width = 4}`
      > - `T -> real {T.type = real, T.width = 8}`
      > - `T -> array[num] of T1 {T.type = array(num.val, T1.type); T.width = num.val * T1.width}`
      >
    - $T\rarr\uarr T_1\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~T.type=pointer(T_1.type);\\ &~~~~T.width=4;\\ &\} \end{align*}

      $$

      > 形成指针后要设置其**类型和宽度**
      >
  - **基本类型**的形成：

    - $B\rarr int\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~B.type=int;\\ &~~~~B.width=4;\\ &\} \end{align*}

      $$

      > 形成整型后要记录其类型和宽度
      >
    - $B\rarr real\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~B.type=real;\\ &~~~~B.width=8;\\ &\} \end{align*}

      $$

      > 形成实型后要设置其类型和宽度
      >
  - **数组标志**的形成：

    - $C\rarr\epsilon\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~C.type=t;\\ &~~~~C.width=w;\\ &\} \end{align*}

      $$

      > 数组标志结束后要从 `t`和 `w`中读取信息，以便后续**数组类型和宽度**的计算
      >
    - $C\rarr[num]C_1\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~C.type=array(num.val,C_1.type);\\ &~~~~C.width=num.val*C_1.width;\\ &\} \end{align*}

      $$

      > 形成数组标志时要用**数组构造符**其设置类型并**计算宽度**
      >

---

*嵌套过程声明语句的SDT：*

- 特殊变量

  - `tbptr`：保存嵌套声明的**外层符号表**的栈
  - `offset`：保存嵌套声明的**外层偏移量**的栈
- 副作用

  - `maketable(previous)`：创建一个**新的符号表，访问链**指向 `previous`
  - `enter(table, name, type, offset)`：向指定符号表中添加变量记录
  - `addwidth(table, width)`：将**符号表大小**记录在表头上
  - `enterproc(table, name, newtable)`：在 `table`中为 `name`建立表项，指向 `newtable`
- 语法规则和语义动作

  - 开始/程序声明：`P -> prog id (input,output) M D; S {a}`

    ```
    M: {
        t := mktable(nil);
        push(t, tbptl);
        push(0, offset);
    }
    a: {
        addwidth(top(tblptr), top(offset));
        pop(tblptr);
        pop(offset);
    }
    ```

    > program形成前，创建根符号表；program形成后，记录宽度于表头，出栈
    >
  - 声明语句

    - `D -> D; D`
    - `D -> proc id N D; S {a}`

      ```
      N: {
          t = mktbl(top(tbptr));
          push(t, tbptl);
          push(0, offset);
      }
      a: {
          t := top(tblptr);
          addwidth(t, top(offset));
          pop(tblptr);pop(offset);
          enterproc(top(tblptr), id.name, t);
      }
      ```

      > procedure形成前，创建子符号表，指向父表；procedure形成后，记录宽度于表头，出栈，父表添加指向子表的记录
      >
    - `D -> id : T {a}`

      ```
      a: {
          enter(top(tbptr), id.name, T.type, top(offset));
          top(offset) += T.width
      }
      ```

---

*结构体声明语句的SDT：*

> 为记录类型单独构造一个符号表，也可以类似过程那样嵌套

- `T -> record M D end {a}`

  ```
  M: {
      t = mktbl(nil);
      push(t, tblptr);
      push(0, offset);
  }
  a: {
      T.type = record(top(tblptr)):
      T.width = top(offset);
      pop(tblptr);
      pop(offset);
  }
  ```

### 6.2 简单赋值和运算语句的翻译

*主要任务：*

- 生成**对表达式求值**的三地址码

  > 三地址码中地址不直接参与运算，而是**存放在所指向地址的值参与运算**
  >
  > 例如下文中经常出现的 `E.addr`，如果放到运算表达式中，其实代表的是存放在所指向地址的值
  >
- 正确处理**数组元素**等复杂表达式，将多维数组形式转换成**一维下标索引**

  > 对于**数组元素**要计算其**地址索引**：
  >
  > - $addr(a[i_1][i_2]...[i_k])=base+i_1\times w_1+i_2\times w_2+...+i_k\times w_k $
  > - `a[i1, i2, i3, i4, ...]`相当于 `a[w*(...(i1*n2+i2)*n3+i3)*n4+i4)...)]`
  >
- 符号表：检查变量是否已经**声明**

---

*简单赋值和运算语句的SDT：*

- 文法符号与综合属性

  - `S`**：开始**符号，代表一个**代码块**
    - `S.code`：存放代码块的所有**三地址码**
  - `E`：表达式
    - `E.code`：存放**表达式之间赋值**的三地址码
    - `E.addr`：表达式**值的存放地址**
  - `id`：标识符
    - `id.lexeme`：构成标识符的字符序列
  - `L`：**数组元素**
    - `L.type`：数组元素的**类型**
    - `L.offset`：数组元素的**地址偏移量**
    - `L.array`：数组**入口地址**，也是数组标识符在符号表中记录的地址
- 副作用

  - `lookup(lexeme)`：查询符号表中**标识符**指向的**地址**

    - `lookup(id.lexeme).type.elem`：（如果 `id`是数组标识符）数组元素**类型**
    - `lookup(id.lexeme).type.elem.width`：数组元素**类型的宽度**

      > 数组相关信息会提前存放至**内情向量表**中
      >
  - `newtemp()`：生成**临时变量**并返回其地址

    > 这里虽然叫做“临时变量”，但这个变量依然会被写进**三地址码**中，只是在逻辑上起**临时记录值**的作用。
    >
    > 临时变量对优化有利，但过多的临时变量会增加符号表负担和运行时存储空间。
    >
    > 可以基于临时变量的生存期**动态申请并释放临时变量**
    >
  - `gen(code)`：生成新的**三地址码**（并拼接已生成的三地址码，赋值给综合属性）

    > ⭐️增量翻译：在语义动作中简化类似 `E.code=E1.code||E2.code||gen(xxx)`的代码，直接写成 `gen(xxx)`，这样代表了**生成三地址码**后自动将子结点的 `code`属性与之**顺序拼接**并赋值给父节点的 `code`属性
    >
- 语法规则和语义动作（归约角度理解）

  - 文法开始/**完整赋值语句**的形成：

    - $S\rarr id=E;\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~p=lookup(id.lexeme);\\ &~~~~if~p==nil~then~error;\\ &~~~~gen(p=E.addr);\\ &\} \end{align*}

      $$

      > 形成**单一标识符**赋值语句时，检查是否已经声明，并生成**标识符赋值**的三地址码
      >
    - $S\rarr L=E;\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~gen(L.array[L.offset]=E.addr);\\ &\} \end{align*}

      $$

      > 形成**数组元素**赋值语句时生成**元素地址索引并给其赋值**的三地址码
      >
  - **算术表达式**的形成

    - $E\rarr E_1+E_2\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~E.addr=newtemp();\\ &~~~~gen(E.addr=E_1.addr+E_2.addr);\\ &\} \end{align*}

      $$

      > 形成加法运算表达式时生成用**临时变量存放运算结果**的三地址码
      >
    - $E\rarr E_1*E_2\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~E.addr=newtemp();\\ &~~~~gen(E.addr=E_1.addr*E_2.addr);\\ &\} \end{align*}

      $$

      > 形成乘法运算表达式时生成用**临时变量存放运算结果**的三地址码
      >
    - $E\rarr-E_1\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~E.addr=newtemp();\\ &~~~~gen(E.addr=uminus~E_1.addrr);\\ &\} \end{align*}

      $$

      > 形成取相反数运算表达式时生成用**临时变量存放运算结果**的三地址码
      >
    - $E\rarr(E_1)\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~E.addr=E_1.addr;\\ &\} \end{align*}

      $$

      > 形成括号运算表达式时传递变量地址
      >
    - $E\rarr id\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~E.addr=lookup(id.lexeme);\\ &~~~~if~E.addr==nil~then~error;\\ &\} \end{align*}

      $$

      > 由标识符形成表达式时要检查是否**声明**并**记录标识符地址**
      >
  - **数组元素表达式**的形成

    - $E\rarr L\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~E.addr=newtemp();\\ &~~~~gen(E.addr=L.array[L.offset]);\\ &\} \end{align*}

      $$

      > 形成**完整数组元素表达式**时生成用**临时变量存放数组元素地址索引**的三地址码
      >
    - $L\rarr id[E]\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~L.array=lookup(id.lexeme);\\ &~~~~if~L.array==nil~then~error;\\ &~~~~L.type=L.array.type.elem;\\ &~~~~L.offset=newtemp();\\ &~~~~gen(L.offset=E.addr*L.type.width);\\ \} \end{align*}

      $$

      > 确定数组**标识符**后，传递**数组名**、数组元素**类型**，计算数组元素**偏移量**，并生成 用类型**宽度**和表达式值计算**偏移量** 的三地址码
      >
    - $L\rarr L_1[E]\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~L.array=L_1.array;\\ &~~~~L.type=L_1.type.elem;\\ &~~~~t=newtemp();\\ &~~~~gen(t=E.addr*L.type.width);\\ &~~~~L.offset=newtemp();\\ &~~~~gen(L.offset=L_1.offset+t);\\ \} \end{align*}

      $$

      > 更高维数组元素形成时，传递**数组名**、数组**类型**，计算数组元素偏移量，生成 借助**临时变量**计算**更深维度偏移量** 的三地址码
      >

---

*数组元素的另一种SDT：*

- 文法符号与综合属性

  - `L.addr`：数组**基址**
  - `L.offset`：数组元素**偏移量**
  - `Elist.array`： 指向符号表中**数组名表项**
  - `Elist.ndim`： Elist中下标表达式的个数， 即**数组当前维数**
  - `Elist.addr`： 存放下标表达式计算出来的值
- 副作用

  - `limit(array, j)`：返回 `nj`

    > 代表第 `j`维的宽度，可以从数组的**内情向量表**中获取
    >
- 语法规则和语义动作（归约的角度）

  - `L -> id {a}`

    ```
    a: {
        L.addr = id.addr;
        L.offset = null;
    }
    ```
  - `Elist -> id[E {a}`

    ```
    a: {
        Elist.addr = E.addr;
        Elist.ndim = 1;
        Elist.array = id.addr;
    }
    ```

    > 数组元素刚开始形成时，记录**下标值、维度、标识符**
    >
  - `Elist -> Elist1, E {a}`

    ```
    a: {
        t = newtmp;
        m = Elist1.ndim + 1;
        gencode(t = Elist1.addr * limit(Elist1.array, m));
        gencode(t = t + E.addr);
        Elist.array = Elist1.array;
        Elist.addr = t;
        Elist.ndim = m;
    }
    ```

    > 生成临时变量计算**深一维度的偏移量**，传递**下标值**、**维度**、**标识符**
    >
    > `a[i1, i2, i3, i4, ...]`
    >
    > `a[w*(...(i1*n2+i2)*n3+i3)*n4+i4)...)]`
    >
  - `L -> Elist] {a}`

    ```
    a: {
        L.addr = newtmp;
        L.offset = newtmp;
        gencode(L.addr = base(Elist.array)-invariant(Elist.array));
        gencode(L.offset = Elist.addr * w)
    }
    ```

    > 数组元素标志形成结束后，计算最终的**数组基址**和**偏移量**
    >

### 6.3 布尔表达式的翻译

*主要任务：*

- 对布尔表达式进行求值（数值表示法）
- 处理布尔表达式在不同逻辑值下的**跳转**（真假出口表示法）

---

*布尔表达式的SDT：*

- 文法符号与属性

  - `B`：布尔表达式
    - `B.true`：布尔表达式的“真”出口，也就是表达式为真时，下一条要执行的语句
    - `B.false`：布尔表达式的“假”出口，也就是表达式为假时，下一条要执行的语句
    - `B.code`：布尔表达式翻译出的三地址码
    - `B.addr`：布尔表达式的值
  - `E`：表达式
    - 与**赋值语句**中的一致
  - `relop`：关系运算符的正则定义，包括 `<, <=, >, >=, ==, !=`
  - `or、and、not`
  - 优先级：`not > and > or`
  - 在语法规则中，可以通过人为地限制**使用产生式归约的条件**来实现不同的优先级
  - `true、false`
- 副作用

  - `newlabel()`
  - `label(L)`
  - `gen(code)`
  - `nextquad`：下一条三地址指令的序号
- 语法规则和语义动作（数值表示法、从归约的角度理解）

  - `B -> E1 relop E2`

    ```
    a : {
        gen(if E1.addr relop E2.addr goto nextquad+3);
        gen(B.addr = 0);
        gen(goto nextquad+2);
        gen(B.addr = 1);
    }
    ```
  - `B -> true`

    ```
    a : {
        B.addr = newtmp;
        gen(B.addr = 1);
    }
    ```
  - `B -> false`

    ```
    a : {
        B.addr = newtmp;
        gen(B.addr = 0);
    }
    ```
  - `B -> B1 or B2`

    ```
    a : {
        B.addr = newtmp;
        gen(B.addr = B1.addr or B2.addr);
    }
    ```
  - `B -> B1 and B2`

    ```
    a : {
        B.addr = newtmp;
        gen(B.addr = B1.addr and B2.addr);
    }
    ```
  - `B -> not B1`

    ```
    a : {
        B.addr = newtmp;
        gen(B.addr = not B1.addr);
    }
    ```
  - `B -> (B1)`

    ```
    a : {
        B.addr = B1.addr;
    }
    ```
- 语法规则和语义动作（真假出口表示法、从推导的角度理解）

  - 由**关系运算符**形成布尔表达式

    - $B\rarr E_1~relop~E_2\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~gen(if~E_1.addr~relop~E_2.addr~goto~B.ture);\\ &~~~~gen(goto~B.false);\\ &\}\\ \end{align*}

      $$

      > 生成关系运算符的**跳转**三地址码
      >
  - 由**逻辑值**形成布尔表达式

    - $B\rarr true\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~gen(goto~B.true);\\ &\}\\ \end{align*}

      $$

      > 直接生成跳转到**真出口**的三地址码
      >
      > 这里所说的“**出口**”指的就是要跳转到的**指令标号**
      >
    - $B\rarr false\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~gen(goto~B.false);\\ &\}\\ \end{align*}

      $$

      > 直接生成跳转到**假出口**的三地址码
      >
  - 通过**逻辑运算符**连接布尔表达式

    - $B\rarr(\{a_1\}B_1)$

      $$
      \begin{align*} &a_1:\{\\ &~~~~B_1.true=B.true;\\ &~~~~B_1.false=B.false;\\ &\}\\ \end{align*}

      $$

      > 计算继承属性，让其**真、假出口**与父表达式保持相等
      >
    - $B\rarr not\{a_1\}B_1$

      $$
      \begin{align*} &a_1:\{\\ &~~~~B_1.true=B.false;\\ &~~~~B_1.false=B.true;\\ &\}\\ \end{align*}

      $$

      > 让其**真、假出口**与父表达式保持相反
      >
    - $B\rarr\{a_1\}B_1~or~\{a_2\}B_2$

      $$
      \begin{align*} &a_1:\{\\ &~~~~B_1.false=newlabel();\\ &~~~~B_1.true=B.true;\\ &\}\\ &a_2:\{\\ &~~~~label(B_1.false);\\ &~~~~B_2.true=B.true;\\ &~~~~B_2.false=B.false;\\ &\}\\ \end{align*}

      $$

      > 计算B1继承属性时，真出口可以确定是父B的真出口，但假出口的代码是B2，还没生成，所以newlabel
      >
      > 计算B2继承属性时，马上要生成B2的代码了，所以B1的假出口可以确定了，B2的真假出口也可以由父B确定
      >
    - $B\rarr\{a_1\}B_1~and~\{a_2\}B_2$

      $$
      \begin{align*} &a_1:\{\\ &~~~~B_1.true=newlabel();\\ &~~~~B_1.false=B.false;\\ &\}\\ &a_2:\{\\ &~~~~label(B_1.true);\\ &~~~~B_2.true=B.true;\\ &~~~~B_2.false=B.false;\\ &\}\\ \end{align*}

      $$

      > 与 `or`类似
      >
- 语法规则和语义动作（真假出口表示法、仅为L-SDD）

  - `B -> E1 relop E2`

    ```
    a : {
        B.code = gen(if E1.addr relop E2.addr goto B.ture)
            ||gen(goto B.false);
    }
    ```
  - `B -> true`

    ```
    a : {
        B.code = gen(goto B.true);
    }
    ```
  - `B -> false`

    ```
    a : {
        B.code = gen(goto B.false);
    }
    ```
  - `B -> B1 or B2`

    ```
    a : {
        B1.true = B.true;
        B1.false = newlabel;
        B2.true = B.true;
        B2.false = B.false;
        B.code = B1.code||gen(B1.false:)||B2.code
    }
    ```
  - `B -> B1 and B2`

    ```
    a : {
        B1.true = newlabel;
        B1.false = B.false;
        B2.true = B.true;
        B2.false = B.false;
        B.code = B1.code||gen(B1.true:)||B2.code
    }
    ```
  - `B -> not B1`

    ```
    a : {
        B1.true = B.flase;
        B1.false = B.true;
        B.code = B1.code
    }
    ```
  - `B -> (B1)`

    ```
    a : {
        B1.true = B.true;
        B1.false = B.false;
        B.code = B1.code
    }
    ```

### 6.4 控制流语句的翻译

*主要任务：*

- 结合布尔表达式的翻译，生成具有**控制流结构**的三地址码
- 正确处理**指令标号**的记录和**跳转**三地址码的生成

---

*控制流语句的代码结构：*

- 跳转的逻辑结构很简单，重点是在合适的地方插入 `goto`语句

  > 详见编译原理随堂笔记仓库
  >

---

*控制流语句的SDT：*

- 文法符号与属性

  - `P`：开始符号
  - `S`：控制流代码块

    - `S.code`：综合属性，存放完整的三地址码
    - `S.next`：继承属性，是一个地址，地址中存放了紧跟在 `S.code`之后的指令标号，即 `S`**后继指令的标号**

      - > **指令标号**可以标识一条**三地址指令**
        >
    - `S.first`：继承属性，是一个地址，地址中存放了在 `S.code`的**第一条指令的标号**
  - `B`：布尔表达式

    - `B.ture`：继承属性，是一个地址，地址中存放了当 `B`为真时控制流转向的指令标号
    - `B.false`：继承属性，是一个地址，地址中存放了当 `B`为假时控制流转向的指令标号
  - `E`：表达式

    - > 与赋值语句中的一致
      >
  - `L`：数组元素

    - > 与赋值语句中的一致
      >
- 副作用

  - `newlabel()`：生成一个用于**存放标号**的临时变量，返回其**地址**
  - `label(L)`：将**下一条**三地址指令的**标号**赋值给 `L`（指向的地址）
  - `gen(code)`
- 语法规则和语义动作（真假出口表示法、从推导的角度理解）

  - 文法开始/完整控流代码块形成：

    - $P\rarr\{a_1\}S\{a_2\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~S.next=newlabel();\\ &\}\\ &a_2:\{\\ &~~~~label(S.next);\\ &\} \end{align*}

      $$

      > 形成代码块前，先生成存放其后继指令的**地址空间**（因为这是继承属性，规定要这么算，而且**代码块内**可能会用到）；
      >
      > 形成代码块后，将**下一条**三地址指令标号赋值给其**后继指令**
      >
    - $S\rarr\{a_1\}S_1\{a_2\}S_2$

      $$
      \begin{align*} &a_1:\{\\ &~~~~S_1.next=newlabel();\\ &\}\\ &a_2:\{\\ &~~~~label(S_1.next);\\ &~~~~S_2.next=S.next\\ &\} \end{align*}

      $$

      > next继承属性肯定是要在符号出现前计算的，能用父S确定的就直接给父S的next，确定不了的（相应代码结构还没出现）就newlabel
      >
  - **完整赋值语句**的形成：$S\rarr id=E;\{a\}|L=E;\{a\}$

    > 上一小节已经讲过，这里省略
    >
  - 控制流结构的形成

    - $S\rarr if~\{a_1\}B~then~\{a_2\}S_1$

      $$
      \begin{align*} &a_1:\{\\ &~~~~B.true=newlabel();\\ &~~~~B.false=S.next;\\ &\}\\ &a_2:\{\\ &~~~~label(B.ture);\\ &~~~~S_1.next=S.next;\\ &\} \end{align*}

      $$

      > 形成布尔表达式前计算继承属性，false能用父S确定的，true还没生成，所以要等到S1之前用label赋值，然后S1的next继承属性用父S确定即可
      >
    - $S\rarr if~\{a_1\}B~then~\{a_2\}S_1~\{a_3\}else~\{a_4\}S_2$

      $$
      \begin{align*} &a_1:\{\\ &~~~~B.true=newlabel();\\ &~~~~B.false=newlabel();\\ &\}\\ &a_2:\{\\ &~~~~label(B.ture);\\ &~~~~S_1.next=S.next;\\ &\}\\ &a_3:\{\\ &~~~~gen(goto~S.next);\\ &\}\\ &a_4:\{\\ &~~~~label(B.false);\\ &~~~~S_2.next=S.next;\\ &\} \end{align*}

      $$

      > 与 `if-then`类似，要么能用父S.next确定，要么还没生成，先newlabel，到对应的位置再label；必须要注意的是，记得**生成S1之后的goto**
      >
    - $S\rarr while~\{a_1\}B~do~\{a_2\}S_1\{a_3\}$

    $$
    \begin{align*} &a_1:\{\\ &~~~~S.begin=newlabel();\\ &~~~~label(S.begin);\\ &~~~~B.true=newlabel();\\ &~~~~B.false=S.next;\\ &\}\\ &a_2:\{\\ &~~~~label(B.true);\\ &~~~~S_1.next=S.begin;\\ &\}\\ &a_3:\{\\ &~~~~gen(goto~S.begin);\\ &\}\\ \end{align*}

    $$

    > 与前面 `if`的类似，这里单独注意一下 `S.begin`和 `goto`，因为 `while`的特点就是会跳回前面
    >
- 语法规则和语义动作（真假出口表示法、仅为L-SDD）

  - `S -> if B then S1`

    ```
    a: {
        B.true = newtmp;
        B.false = S.next;
        S1.next = S.next;
        S.code = B.code||gen(B.true:)||S1.code
    }
    ```
  - `S -> if B then S1 else S2`

    ```
    a: {
        B.true = newtmp;
        B.false = newtmp;
        S1.next = S.next;
        S2.next = S.next;
        S.code = B.code||gen(B.true:)||S1.code
            ||gen(goto S.next)
            ||gen(B.false:)||S2.code
    }
    ```
  - `S -> while B do S1`

    ```
    a: {
        S.begin = newtmp;
        B.true = newtmp;
        B.false = S.next;
        S1.next = S.begin;
        S.code = gen(S.begin:)||B.code
            ||gen(B.true:)||S1.code
            ||gen(goto S.begin)
    }
    ```
  - `S -> S1; S2`

    ```
    a: {
        S1.next = newtmp;
        S2.next = S.next;
        S.code = S1.code||gen(S1.next)||S2.code
    }
    ```

*`switch-case`语句的翻译：*

- `switch-case`的直观翻译方式：

  $$
  switch~E\{a_1\}\\ case~V_1:\{a_2\}S_1\{a_3\}\\ case~V_2:\{a_4\}S_2\{a_5\}\\ ...\\ case~V_{n-1}:\{a_{2n-2}\}S_{n-1}\{a_{2n-1}\}\\ default~:\{a_{2n}\}S_n\{a_{2n+1}\}

  $$

  - 新增特殊变量

    - `Vk`：第 `k`个分支的**入口值**
    - `Lk`：存放第 `k+1`个分支**第一条指令标号**的地址空间
    - `t`：存放分支依据**表达式的值**
    - `next`：存放整体代码块**下一条指令标号**的地址空间

    $$
    \begin{align*} &a_1:\{\\ &~~~~t=newtemp();\\ &~~~~gen(t=E.addr);\\ &~~~~next=newlabel();\\ &\}\\ &a_{2k-2}:\{\\ &~~~~label(L_{k-1});\\ &~~~~L_k=newlabel();\\ &~~~~gen(if~t~!=V_k~goto~L_k);\\ &\}\\ &a_{2k-1}:\{\\ &~~~~gen(goto~next);\\ &\}\\ &a_{2n}:\{\\ &~~~~label(L_{n-1});\\ &\}\\ &a_{2n+1}:\{\\ &~~~~label(next);\\ &\}\\ \end{align*}

    $$
  - `switch-case`语句开始分支测试前，生成将依据**表达式值**保存至临时变量的三地址码，并为存放**整体代码块下一条指令的标号**开辟内存空间

    > 那个 `next=newlabel()`放在第一次使用 `next`前也可以
    >
  - 每个测试分支中，形成代码块前，先给该**分支对应标号赋值**，再生成**不满足条件跳转**至下一个分支标号的三地址码；形成代码块后，生成跳转至整体代码块下一条指令的三地址码

    > 第一个测试分支不需要给自己的标号赋值，只需要生成不满足条件的跳转三地址码
    >
  - 默认分支中，形成代码块前，给该**分支对应标号赋值**；形成代码块后，给**整体代码块下一条指令对应**的标号赋值
- `switch-case`的**分支测试代码集中**翻译方式：

  $$
  switch~E\{a_1\}\\ case~V_1:\{a_2\}S_1\{a_3\}\\ case~V_2:\{a_4\}S_2\{a_5\}\\ ...\\ case~V_{n-1}:\{a_{2n-2}\}S_{n-1}\{a_{2n-1}\}\\ default~:\{a_{2n}\}S_n\{a_{2n+1}\}

  $$

  - 新增特殊变量

    - `test`：分支集中测试块的第一条指令标号地址
  - 新增副作用

    - `map`：记录分支测试**入口值**与分支测试**标号**的映射关系，方便批量生成**分支测试代码**

    $$
    \begin{align**} &a_1:\{\\ &~~~~t=newtemp();\\ &~~~~gen(t=E.addr);\\ &~~~~test=newlabel();\\ &~~~~gen(goto~test);\\ &~~~~next=newlabel();\\ &\}\\ &a_{2k-2}:\{\\ &~~~~L_k=newlabel();\\ &~~~~label(L_{k});\\ &~~~~map(V_k,L_k);\\ &\}\\ &a_{2k-1}:\{\\ &~~~~gen(goto~next);\\ &\}\\ &a_{2n}:\{\\ &~~~~L_n=newlabel();\\ &~~~~label(L_{n});\\ &\}\\ &a_{2n+1}:\{\\ &~~~~gen(goto~next);\\ &~~~~label(test);\\ &~~~~gen(if~t=V_k~goto~L_k);\\ &\}\\ \end{align**}

    $$
  - `switch-case`语句开始分支测试前，生成将依据**表达式值**保存至临时变量的三地址码，生成**跳转至集中分支测试**的三地址码，并为存放**整体代码块下一条指令的标号**开辟内存空间
  - 每个测试分支中，形成代码块前，开辟该分支对应的标号，并给**标号赋值**为下一条指令，再将该分支测试**入口值**与**标号**的添加至映射表；形成代码块后，生成跳转至整体代码块下一条指令的三地址码
  - 默认分支中，形成代码块前，开辟该分支对应的标号，并给**标号赋值**为下一条指令；形成代码块后，生成跳转至整体代码块下一条指令的三地址码，再给**集中分支测试的标号**赋值，然后根据**映射表**批量生成分支**入口值对比并跳转至对应标号**的三地址码

    > 可以增加一种 `case`指令，`case t V L`等同于 `if t==V goto L`，但 `case`指令更容易被最终的代码生成器**探测**到，从而对这些指令进行**特殊处理**
    >

---

*`for-to-step-do`语句的翻译：*

- 再说 吧

---

*`repeat-until`语句的翻译：*

- 再说 吧

### 6.5 过程调用语句的翻译

*主要任务：*

- 解析过程调用的参数，生成**设置实参和调用过程**的三地址码

---

*过程调用语句的代码结构：*

- 语句模式：`id(E1, E2, ..., En)`
- 代码流程

  - 运算各表达式的三地址码，计算参数值：

    ```
    id(
    	E1.code,
    	E2.code,
    	...
    	En.code
    )
    ```
  - 通过 `param`指令将各表达式的值作为函数的实参：

    ```
    param E1.addr
    param E2.addr
    ...
    param En.addr
    ```

    > 这种是 `param`指令集中的形式。也可以让 `param Ek.addr`指令紧跟在 `Ek.code`后面，就是分散形式。
    >
    > 分散形式下，需要使用一种数据结构（通常是队列 `q`）来存放 `Ek.addr`，以便集中生成 `param`指令
    >
  - 调用函数：`call id.addr n`

    > `n`代表参数个数
    >

---

*过程调用语句的SDT：*

- 文法符号与属性

  - `S`：文法开始符号/过程调用代码结构
  - `Elist`：参数列表
  - `E`：参数表达式
    - `E.addr`：表达式**值的存放地址**
- 副作用

  - `gen(code)`
- 语法规则和语义动作

  - 文法开始/形成**过程调用**框架：$S\rarr call~id(Elist)\{a_1\}$

    $$
    \begin{align*} &a_1:\{\\ &~~~~n=0;\\ &~~~~for~q中的每个t~do\\ &~~~~~~~~gen(param~t);\\ &~~~~~~~~n=n+1;\\ &~~~~gen(call~id.addr,n);\\ &\}\\ \end{align*}

    $$

    > 过程调用框架形成后，根据队列 `q`集中生成所有**设置实参**的 `param`三地址指令，最后再生成一条**过程调用**的三地址指令
    >
  - 形成**参数列表**

    - $Elist\rarr E\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~将q初始化为只包含E.addr的队列;\\ &\}\\ \end{align*}

      $$

      > 参数列表开始形成时初始化队列 `q`
      >
    - $Elist\rarr Elist_1,E\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~将E.addr添加到q的队尾;\\ &\}\\ \end{align*}

      $$

      > 参数列表中每增加一个参数就添加一个参数地址至队列 `q`中
      >

### 6.6 回填

*基本思想：*

- 生成**跳转**三地址码时，暂不指定跳转的**目标标号**，并将这样的指令放入**列表**中，同一个列表中所有跳转指令的**目标相同**，待能确定目标时，再**填充**列表中指令的目标标号
- 待填充跳转指令组成的**列表**会通过文法符号**综合属性**进行传递，不再需要使用 `next true false`这类**继承属性**了，更符合**归约**的思想

> 如果不使用回填，可以两遍扫描，先把**语法分析树**建好，再遍历树，确定标号。但这样效率较低

---

*布尔表达式的回填：*

- 有改动或新增的文法符号及其综合属性

  - `B`：布尔表达式
    - `B.truelist`：指向包含待填充跳转指令的**列表**，列表中的跳转指令**目标均为 `B`的真出口**
    - `B.falselist`：指向包含待填充跳转指令的**列表**，列表中的跳转指令**目标均为 `B`的假出口**
  - `M`：辅助记录的符号
    - `M.quad`：会将下一条指令的标号暂存至该综合属性，之后会用到
- 新增的特殊变量

  - `nextquad`：即将生成的下一条三地址码的标号
- 新增的副作用

  - `makelist(i)`：创建一个只包含跳转指令 `i`的列表，返回列表**指针**
  - > 这里的 `i`是这条跳转指令本身的标号，不是目标标号
    >
  - `merge(p1, p2)`：将 `p1`和 `p2`指向的两个列表合并，返回合并后列表**指针**
  - `backpatch(p, i)`：将 `i`作为**目标标号**填充 `p`指向的列表中的所有**跳转指令**
- 有改动的语法规则和语义动作

  - 由**关系运算符**形成布尔表达式：$B\rarr E_1~relop~E_2\{a_1\}$

    $$
    \begin{align*} &a_1:\{\\ &~~~~B.truelist=makelist(nextquad);\\ &~~~~B.falselist=makelist(nextquad+1);\\ &~~~~gen(if~E_1.addr~relop~E_2.addr~goto~\_);\\ &~~~~gen(goto~\_);\\ &\}\\ \end{align*}

    $$

    > 先设置待**填充跳转指令列表**，把**即将生成的两条指令**分别加入真假出口对应的两个列表，再生成关系运算符的**待填充跳转三地址码**
    >
  - 由**逻辑值**形成布尔表达式

    - $B\rarr true\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~B.truelist=makelist(nextquad);\\ &~~~~gen(goto~\_);\\ &\}\\ \end{align*}

      $$

      > 先设置待**填充跳转指令列表**，把**即将生成的指令**加入真出口对应的列表，再生成**待填充的跳转三地址码**
      >
    - $B\rarr false\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~B.falselist=makelist(nextquad);\\ &~~~~gen(goto~\_);\\ &\}\\ \end{align*}

      $$

      > 先设置待**填充跳转指令列表**，把**即将生成的指令**加入假出口对应的列表，再生成**待填充的跳转三地址码**
      >
  - 通过**逻辑运算符**连接布尔表达式

    - $B\rarr(B_1)\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~B_1.truelist=B.truelist;\\ &~~~~B_1.falselist=B.falselist;\\ &\}\\ \end{align*}

      $$

      > 子表达式形成后，让其**真、假出口列表**与父表达式保持相等
      >
    - $B\rarr not~B_1\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~B_1.truelist=B.falselist;\\ &~~~~B_1.falselist=B.truelist;\\ &\}\\ \end{align*}

      $$

      > 相反子表达式形成后，让其**真、假出口列表**与父表达式保持相反
      >
    - $B\rarr B_1~or~M~B_2\{a_1\}$

      $M\rarr\epsilon\{a_2\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~backpatch(B_1.falselist,M.quad);\\ &~~~~B.truelist=merge(B_1.truelist,B_2.truelist);\\ &~~~~B.falselist=B_2.falselist;\\ &\}\\ &a_2:\{\\ &~~~~M.quad=nextquad;\\ &\}\\ \end{align*}

      $$

      > 子表达式形成并连接后：
      >
      > - 处理不短路的跳转位置：用记录下的第二个布尔表达式的**第一条指令标号**回填第一个子表达式的**假出口列表**
      > - 处理B的出口列表
      >
      >   - 真出口合并：将两个子表达式的**真出口列表合并**至父表达式的真出口列表
      >   - 假出口：将第二个子表达式的**假出口列表**赋值给父表达式的假出口列表
      >
      > 父表达式的真假出口列表待**控制流语句**形成后回填
      >
    - $B\rarr B_1~and~M~B_2\{a_1\}$

      $M\rarr\epsilon\{a_2\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~backpatch(B_1.truelist,M.quad);\\ &~~~~B.falselist=merge(B_1.falselist,B_2.falselist);\\ &~~~~B.truelist=B_2.truelist;\\ &\}\\ &a_2:\{\\ &~~~~M.quad=nextquad;\\ &\}\\ \end{align*}

      $$

      > 子表达式形成并连接后：
      >
      > - 处理不短路的跳转位置：用记录下的第二个布尔表达式的**第一条指令标号**回填第一个子表达式的**真出口列表**
      > - 处理B的出口列表
      >   - 假出口合并：将两个子表达式的**假出口列表合并**至父表达式的真出口列表
      >   - 真出口：将第二个子表达式的**真出口列表**赋值给父表达式的假出口列表
      >
      > 父表达式的真假出口列表待**控制流语句**形成后回填
      >

---

*控制流语句的回填：*

- 有改动或新增的文法符号及其综合属性

  - `S`：控制流代码块
    - `S.nextlist`：指向包含待填充跳转指令的**列表**，列表中的跳转指令**目标均为 `S`的下一条指令**
  - `M`：辅助记录的符号
    - `M.quad`：会将下一条指令的标号暂存至该综合属性，之后会用到
  - `N`：辅助记录的符号
    - `N.nextlist`：会将包含**下一条跳转指令**的列表指针标号暂存至该综合属性，之后会用到
- 新增的特殊变量

  - `nextquad`
- 新增的副作用

  - `makelist(i)`
  - `merge(p1, p2)`
  - `backpatch(p, i)`
- 有改动的语法规则和语义动作

  - 文法开始/完整控流代码块形成：

    - $P\rarr S\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~backpatch(S.nextlist,nextquad);\\ &\}\\ \end{align*}

      $$

      > 形成代码块后，用**下一条**三地址指令标号回填整体代码块的**后继列表**；
      >
      > 这条回填产生式是我自己猜的，我希望是对的
      >
    - $S\rarr S_1~M~S_2\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~backpatch(S_1.nextlist, M.quad)\\ &~~~~S.nextlist=S_2.nextlist\\ &\}\\ \end{align*}

      $$

    > 两个代码块拼接完成后，先用记录下的第二个代码块的**第一条指令标号**回填第一个代码块的**后继列表**，再将第二个代码块的后继列表赋值给整体代码块的后继列表
    >
  - **完整赋值语句**的形成：$S\rarr id=E;\{a\}|L=E;\{a\}$

    $$
    \begin{align*} &a:\{\\ &~~~~S.nextlist=null;\\ &\}\\ \end{align*}

    $$

    > 完整赋值语句形成后，直接让代码块**后继列表为空**即可；
    >
    > 因为赋值语句只是顺序执行，不需要特殊的跳转
    >
  - 控制流结构的形成

    - $S\rarr if~B~then~M~S_1\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~backpatch(B.truelist, M.quad);\\ &~~~~S.nextlist=merge(B.falselist,S_1.nextlist);\\ &\}\\ \end{align*}

      $$

      > 单分支控制流形成后：
      >
      > - 真出口：回填子代码块**第一条指令**
      > - 假出口：与子代码块的 `nextlist`合并，给到父代码块。因为 `S.next`完全没出现在这条产生式中
      >
    - $S\rarr if~B~then~M_1~S_1~N~else~M_2~S_2\{a_1\}$

      $N\rarr\epsilon\{a_3\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~backpatch(B.truelist,M1.quad);\\ &~~~~backpatch(B.falselist,M2.quad);\\ &~~~~S.nextlist=merge(merge(S_1.nextlist,N.nextlist),S_2.nextlist);\\ &\}\\ &a_3:\{\\ &~~~~N.nextlist=makelist(nextquad);\\ &~~~~gen(goto~\_);\\ &\}\\ \end{align*}

      $$

      > 双分支控制流形成后：
      >
      > - 真出口：回填第一个子代码块**第一条指令**
      > - 假出口：回填第二个子代码块**第一条指令**
      > - 中途跳转出口：与两个**子代码块**的 `nextlist`合并然后给到父代码块
      >
    - $S\rarr while~M_1~B~do~M_2~S_1\{a_1\}$

      $$
      \begin{align*} &a_1:\{\\ &~~~~backpatch(S_1.nextlist,M_1.quad);\\ &~~~~backpatch(B.truelist,M_2.quad);\\ &~~~~S.nextlist=B.falselist;\\ &~~~~gen(goto~M_1.quad);\\ &\}\\ \end{align*}

      $$

      > 循环控制流形成后：
      >
      > - 真出口：回填子代码块**第一条指令**
      > - 假出口：产生式中没出现，给到父代码块，待之后回填
      > - 子代码块 `nextlist`：回填布尔代码块**第一条指令**
      > - 中途跳转：跳回布尔表达式
      >

## 7 运行存储分配

### 7.1 运行存储分配概述

*运行存储分配策略：*

- 编译器要为源程序中出现的一些**数据对象**分配**运行时的存储空间**
- 静态存储分配策略：对于在编译时可以确定大小的**数据对象**，可以在**编译时**就静态地分配存储空间

  > **静态**指的是**编译时、空间上**
  >
- 动态存储分配策略：对于不能在编译时完全确定大小的**数据对象**，仅在编译时产生必要信息，而在**运行时**动态地分配存储空间

  > **动态**指的是**运行时、时间上**
  >

  - 栈式存储分配
  - 堆式存储分配

---

*名字与变量：*

- 概念问题：

  - 名字：编译时的名字
  - 变量/左值：运行时的内存位置
  - 标识符：名字的一种，指示数据对象的入口
  - 右值：运行时某一时刻变量的值
- 名字到值的映射

  - `名字 --环境--> 左值/变量 --状态--> 值/右值`
  - 绑定：**环境**将**名字**绑定到**左值/变量**上

---

*作用域：*

- 静态作用域

  - 定义：编译时即可确定声明的作用域，即**编译**时就可以确定每个变量**来自于哪个声明**
  - 寻找变量规则：

    - 声明语句在一个程序块内，则作用域就是这个**程序块**
    - 如果允许嵌套，那么在寻找变量时首先找本层，然后找**最近的外层**，即**最近作用域规则**

      > **空间**上最近
      >
- 动态作用域

  - 定义：不是静态作用域，即有些变量只能在**运行时**确定其**来自于哪个声明**
  - 寻找变量规则：找到最近被调用的过程中的声明

    > **时间**上最近
    >

---

*内存划分与过程活动：*

- 运行时内存划分：

  - **静态代码**区
  - **静态数据**区
  - **动态数据**区域
    - **栈区**
    - 空闲内存
    - 堆区
- 活动记录：

  - 概念：

    - 活动(activation)：过程体的**每次执行**称为该过程的一个活动
    - 活动记录(activation record)：编译器以**过程**为单位、为**活动**分配的、用来管理**一次执行所需信息**的连续**存储空间**

      > 活动记录的体积在编译时是可以确定的
      >
  - 一般形式/构成

    - 实参
    - 返回值
    - 控制链/动态链：指向**调用者**的活动记录
    - 访问链/静态链：用于访问**非局部数据**
    - 保存的**机器状态**/机器状态字段：各种**寄存器**值和其他**状态信息**
    - 局部数据
    - 临时变量：中间代码生成时需要的临时变量
- 参数传递方式

  - 传值：新开变量，传右值
  - 传地址：如果实参是左值，则传左值；如果实参不是左值，则创建**临时变量**充当左值，设置其右值，然后传左值
  - 传值结果：同时传左值和右值，在主体中**只使用右值**，在**结束**前修改**左值状态**
  - 传名：过程体中用到形参的地方直接替换成一模一样的实参左值（包括运算符）

### 7.2 静态存储分配

> 静态数据和静态代码无疑是静态存储分配的，所以该小节主要讲**活动记录的静态存储分配**

*静态存储分配的规则与条件：*

- 规则：

  - **编译器**为每个**活动记录**直接指定**存储位置**
  - 因此，过程中**标识符的存储位置**可以确定，每次都绑定到同样的存储单元，可以将这些地址编译到目标代码中
- 条件：

  - **数组上下界**必须是常数
  - 不允许**递归调用**
  - 不允许**动态建立**数据实体

    > 满足这些条件的语言有BASIC、FORTRAN等
    >

---

*顺序分配法：*

- 特点：

  - 按照过程出现的先后顺序**逐段分配**存储空间
  - 各过程的活动记录占用**互不相交**的存储空间
- 优点：处理简单
- 缺点：对内存空间的使用不够经济合理

---

*层次分配法：*

- 层次分配的特点：

  - 构建**过程调用图**，确保图中不出现**环**
  - 无相互调用关系的**并列过程**尽量使其局部数据**共享存储空间**
- 层次分配的算法：

  - 依据过程调用图，**从下至上**分配
  - **同层**可以互相“**覆盖**”
  - **上层**从子过程的**最高地址**开始分配

    > 代码实现的算法详见编译原理笔记仓库
    >

### 7.3 栈式存储分配与调用返回序列

*栈式存储分配与活动树：*

- 栈式存储分配的概念：

  - 将过程的**活动记录**以**栈**的形式进行管理
  - 当过程被**调用**时，活动记录**入栈**；当过程**结束**时，活动记录**出栈**
- 栈式存储分配的优点：

  - 允许**活跃时段不交叠**的过程调用**共享存储空间**
  - 非局部变量的相对地址固定，与调用序列无关

    > 关于非局部变量会在后面讲到
    >
- 活动树与控制栈：

  - 活动树的概念：描述程序运行期间控制**进入和离开各个活动**的情况的树
  - 活动树的结构：
    - 每个**结点**对应一个**活动**，根结点是**程序入口**过程的活动
    - **子结点**表示被父结点活动**调用的活动**，按被调用的顺序自左向右排列
    - 一个子结点活动必须在其右兄弟结点活动开始之前结束
  - 活动树与控制栈的关系：
    - 活动树**根的活动记录**位于**栈底**，程序控制所在的活动记录位于**栈顶**
    - **控制栈**中全部活动记录的**序列**对应于**活动树**中从**根结点**到达**当前控制**所在活动结点的**路径**
- 设计活动记录的原则：

  - **传递的项**：调用者和被调用者之间**传递的值**放置在被调用活动记录的**起始位置**
  - **固定长度项**：固定长度的项放置在活动记录的**中间位置**，包括**控制链、访问链、机器状态字段**
  - **不定长度项**：初期不确定长度的项放置在活动记录的**尾部**
  - **栈顶指针**：栈顶指针寄存器 `top_sp`指向活动记录中**局部数据开始的位置**，以该位置作为**基地址**

---

*调用序列与返回序列：*

- 调用序列与返回序列概述：

  - 过程**调用**和过程**返回**都需要执行一些**代码**来管理**活动记录栈**，保存或恢复机器状态字等
  - **调用序列**：实现**过程调用**的**代码段**。为活动记录**分配栈空间**，并填写活动记录的**字段**
  - **返回序列**：实现**过程返回**的**代码段**。回收活动记录的栈空间，**恢复机器状态**，使**调用者过程**能继续执行
  - 调用序列和返回序列中的代码段通常被**分割到调用者过程和被调用者过程**中
- **调用**序列的主要内容：

  - 参数：**调用者**计算实际参数的值
  - 返回地址：**调用者**将返回地址（当前程序计数器的值）存到被调用活动记录的**机器状态字段**中
  - `top_sp`：**调用者**将 `top_sp`的值存到被调用活动记录的**控制链**中，并**增加** `top_sp`的值，使其指向被调用活动记录**局部数据开始的位置**
  - 机器状态：**被调用者**保存寄存器值和其他状态信息（**保存现场**）
  - 局部数据：**被调用者**初始化其**局部数据**并开始执行
  - 访问链：**调用者**设置被调用活动记录的**访问链**

    > 关于访问链会在后面讲到
    >
- **返回**序列的主要内容：

  - 返回值：**被调用者**将**返回值**存到与**参数**相邻的位置
  - `top_sp`：**被调用者**根据**控制链**中的数据恢复 `top_sp`

    > 虽然 `top_sp`的值被减小，但调用者依然可以知道**返回值**的位置
    >
  - 机器状态：**被调用者**根据**机器状态字段**中的信息恢复寄存器值和其他状态信息（**恢复现场**）
  - 返回：**被调用者**根据**机器状态字段**中的信息跳转到**返回地址**

---

*变长数据的存储分配：*

- 变长数据的栈分配策略：

  - 编译时刻不能确定大小的过程**局部对象**可以分配到**运行时刻栈**中

    > 这样的局部对象不算作活动记录的一部分
    >
  - 可以避免对变长数据空间的主动垃圾回收，减少相应开销

    > 现代程序设计语言中，编译时不能确定大小的对象往往分配在**堆区**，但如果是局部对象也可以分配到栈区
    >
- 动态数组的分配：

  - 在活动记录的局部数据中存放**数组指针**

    > **数组指针**在**编译时**可以确定大小，属于**活动记录**的一部分
    >
  - **运行**时在栈中**当前活动记录之下**开辟变长数组空间，存放数组元素

    > 变长数组虽然出现在栈中，但并不是**活动记录**的一部分，因为在**编译时**无法确定大小，需要在**运行时**动态分配
    >

### 7.4 非局部数据与访问链

*非局部数据相关概念：*

- 非局部数据的概念：

  - 语言可分为**支持过程嵌套**声明的和**不支持过程嵌套**声明的

    > 支持过程嵌套：Pascal，不支持过程嵌套：C
    >
  - 支持过程嵌套的语言中，过程可以使用**过程外定义的非局部数据**

    > 过程本就可以使用**过程自身定义**的局部数据和**全局定义**的数据。
    >

    - **全局**变量被分配在**静态区**，使用**静态**确定的地址访问它们
    - **局部**变量被分配在**栈区**，在栈顶活动，通过**运行时**栈的 `top_sp`访问
- 嵌套深度的概念：

  - **过程**的嵌套深度：
    - 不内嵌在任何其他过程中的过程，其嵌套深度为1
    - 如果一个过程p在一个嵌套深度为i的过程中定义，则过程p的嵌套深度为i+1
  - **变量**的嵌套深度：
    - 变量**声明所在过程**的嵌套深度即为该变量的嵌套深度

---

*访问链及其建立：*

- 访问链的概念：

  - 静态作用域规则：只要过程b嵌套在过程a的声明中，过程b就可以访问过程a中声明的对象
  - 访问链指针：在相互**嵌套**的过程的**活动记录**之间建立一种称为**访问链**的指针，使得内嵌的过程可以访问外层过程中声明的对象
- 访问链的建立：

  - 建立规则：如果**过程b**在源代码中**直接嵌套**在**过程a**中，那么**b的任何活动**中的访问链都指向最近的**a的活动**

    > 直接嵌套：过程b声明在过程a中且b的嵌套深度比a的嵌套深度大1
    >
    > 注意区分过程和活动，一个过程在运行时可以有多个活动
    >
  - 建立步骤：建立访问链，其实就是在**调用序列**中加入相关代码，由**调用者**负责建立访问链

    假设嵌套深度为$n_x$的过程x调用嵌套深度为$n_y$的过程y（$x\rarr y$）

    - 如果$n_x<n_y$，即**外层调用内层**，那么需要在y的访问链中放置一个指向x的活动记录的指针

      > 这种情况下y一定是**直接定义**在x中的，因此$n_y=n_x+1$
      >
      > 因为外层**无法进一步深入内层**访问内层中的数据
      >
      > 外调内，内指外
      >
    - 如果$n_x=n_y$，即**本层调用本层**，那么被调用活动记录的访问链与调用者活动记录相同，可以直接**复制**

      > 递归调用自己也是同理
      >
      > 同级调，**复制**
      >
    - 如果$n_x>n_y$，即**内层调用外层**，那么从x的活动记录开始，沿着访问链经过$n_x-n_y+1$步找到的活动记录，就是y的访问链要指向的活动记录

      > 这种情况下，一定存在一个过程z，满足过程x**嵌套**在过程z中，且z中**直接定义**了过程y。在上述过程中经过$n_x-n_y+1$步找到的活动记录就是离栈顶最近的z的活动记录
      >
      > - 这里说的“嵌套”不包括z直接定义x的情况，一定要存在一个嵌套的**中间过程**
      >
      > 内调外，指向最近**公共祖先**（不包括二者本身）
      >

### 7.5 符号表的组织

> 由于本校考试不考查此部分，所以暂时没有知识总结

### 7.6 堆式存储分配

> 由于本校考试不考查此部分，所以暂时没有知识总结

## 8 代码优化

> 由于本校考试不考查此部分，所以暂时没有知识总结

## 9 代码生成

### 9.1 代码生成的主要任务

*指令选择：*

- 选择适当的**目标机指令**来实现中间表示（**IR**）语句
- 目标代码形式

  - 绝对机器语言代码
  - 可重定位的机器语言代码
  - 汇编语言代码

---

*寄存器分配和指派：*

- 选择适当的寄存器存放从内存中加载的值

---

*指令排序：*

- 选择适当的顺序安排指令的执行

### 9.2 目标机与指令选择

*目标机模型：*

- 特性：

  - 指令集：有加载、保存、运算、跳转等操作。指令之间可以有标号
  - 内存编址：内存按字节寻址
  - 寄存器：有n个通用寄存器

    $$
    R_0、R_1、...、R_{n-1}

    $$

    $$



    $$
  - 运算：所有运算分量都是整数
- 主要指令：

  - 加载指令：`LD dst, addr`
  - 保存指令：`ST x, r`
  - 运算指令：`OP dst, src1, src2`
  - 无条件跳转指令：`BR L`
  - 条件跳转指令：`Bcond r, L`

    > 例：`BLTZ r, L`
    >
    > LTZ：Less then Zero
    >
- 寻址模式：

  > `contents(x)`表示取出地址 `x`上的数据，`conteents(R)`表示取出寄存器 `R`中的数据（有时也可以直接用 `R`代替）
  >

  - **变量名**：直接用一个变量名表示**地址**

    > 例：`LD R1, a // R1 = contents(a)`
    >
  - 偏移：用 `基址(偏移量)`的方式表示地址

    - `a(r)`：`a`是变量，`r`是寄存器

      > 例：`LD R1 a(R2) // R1 = contents(a + contens(R2))`
      >
    - `c(r)`：`a`是常整数，`r`是寄存器

      > 例：`LD R1 100(R2) // R1 = contents(100 + contens(R2))`
      >
  - 间接：**指出的地址**中并不存放目标数据，而是又**存放着目标数据所在地址**
  - `*`运算符可以理解成把地址中存放的数据取出来。在寻址模式中意思就是，**指出的地址中存放的数据**是真正要访问的地址

    - `*r`：在寄存器 `r`指示的地址中存放着目标数据所在地址

      > 例：`LD R1, *R2 // R1 = contents(contents(R2))`
      >
    - `*c(r)`：寄存器 `r`中的值再加上常整数 `c`所指示的地址中存放着目标数据所在地址

      > 例：`LD R1, *100(R2) // R1 = contents(contents(100 + contents(R2)))`
      >
  - 立即数：`#c`表示立即数整数 `c`

    > 例：`LD R1, #100 // R1 = 100`
    >

---

*指令选择：*

- **运算**三地址语句：`x = y - z`

  - 目标代码：

    - `LD R1, y`
    - `LD R2, z`
    - `SUB R1, R1, R2`
    - `ST x, R1`

    > 上面列出的4条指令一定能实现运算语句，但在特定情况下可以省略一些指令，例如：
    >
    > - 所需的运算分量已经在寄存器中了
    > - 运算结果不需要放回内存
    >
- **数组寻址**三地址语句：

  > `a`是一个实数数组，每个实数占8字节
  >

  - `b = a[i]`的目标代码：
    - `LD R1, i`
    - `MUL R1, R1, 8`
    - `LD R2, a(R1) // R2 = contents(a + contents(R1))`
    - `ST b, R2`
  - `a[j] = c`的目标代码：
    - `LD R1, c`
    - `LD R2, j`
    - `MUL R2, R2, 8`
    - `ST a(R2), R1 // contents(a + contents(R2)) = R1`
- **指针存取**三地址语句：

  - `x = *p`的目标代码：
  - `LD R1, p`
  - `LD R2, 0(R1) // R2 = contents(0 + contents(R1))`
  - `ST x, R2`
  - `*p = y`的目标代码：
  - `LD R1, p`
  - `LD R2, y`
  - `ST 0(R1), R2 // contents(0 + contents(R1)) = R2`
- **条件跳转**三地址语句：`if x < y goto L`

  ```
  LD R1, x
  LD R2, y
  SUB R1, R1, R2
  ```
- `BLTZ R1, M`

  > `M`是标号为 `L`的三地址语句所产生的若干条目标代码中的第一条指令标号
  >
- **过程调用**三地址语句

  - 静态存储分配：`call callee`的目标代码

    - `ST callee.staticArea, #here + 20 // 存放返回地址`
    - `BR callee.codeArea // 控制流转向被调用过程`

      > `callee.staticArea`：`callee`的活动记录在静态区中的起始位置
      >
      > `callee.codeArea`：`callee`的目标代码在静态代码区中的起始位置
      >
  - 栈式存储分配：`call callee`的目标代码

    - `ADD SP, SP, #caller.recordsize`
    - `ST 0(SP), #here + 16`
    - `BR callee.codeArea`
- **返回**三地址语句

  - 静态存储分配：`return`的目标代码
    - `BR *callee.staticArea`
  - 栈式存储分配：`return`的目标代码
    - `BR *0(SP) // 由被调用者执行`
    - `SUB SP, SP, #caller.recoredsize // 由调用者执行`

---

*指令开销：*

- 概念：存储开销，包括存储**指令本身**和指令涉及的其他**地址**
  - 涉及立即数和变量地址寻址会额外增加一个开销
  - 立即数会额外增加一个开销
  - 其中寄存器不需要额外增加开销
